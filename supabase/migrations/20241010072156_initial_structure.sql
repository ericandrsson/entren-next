-- Extensions
CREATE EXTENSION IF NOT EXISTS "hstore" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "moddatetime" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "postgis" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "postgres_fdw" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "pg_jsonschema" WITH SCHEMA "extensions";

-- Foreign Data Wrapper setup
CREATE SERVER osm_remote_server FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host '135.181.108.171', dbname 'postgres', port '5433');
CREATE USER MAPPING FOR CURRENT_USER SERVER osm_remote_server OPTIONS (user 'postgres', password 'p4ik5IdbSwQBMaUNBUgashGjZUxBhkN9Autx9R9Yj9VeXNgOIMYzhIuapPKn8ti1');
CREATE SCHEMA IF NOT EXISTS osm_import;

-- Import specific tables
IMPORT FOREIGN SCHEMA public FROM SERVER osm_remote_server INTO osm_import;


-- Sequences
CREATE SEQUENCE "public"."places_place_id_seq" START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE "public"."entrances_entrance_id_seq" START WITH 1 INCREMENT BY 1;

-- Custom types
CREATE TYPE "public"."entity_type" AS ENUM ('place', 'entrance', 'photo');
CREATE TYPE "public"."entity_data_source" AS ENUM ('osm', 'user', 'external');
CREATE TYPE "public"."entity_changes_staging_status" AS ENUM ('pending', 'approved', 'rejected');
CREATE TYPE "public"."entity_changes_action_type" AS ENUM ('add', 'update', 'delete', 'approve', 'reject');


-- Users table
CREATE TABLE "public"."users" (
    "id" uuid NOT NULL PRIMARY KEY,
    "email" text,
    "first_name" text,
    "last_name" text,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text)
);

-- Place categories table
CREATE TABLE "public"."place_categories" (
    "category_id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "name" text NOT NULL,
    "name_sv" text NOT NULL,
    "parent_category_id" bigint,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text)
);

-- Example data insertion for place categories
INSERT INTO "public"."place_categories" ("name", "name_sv", "parent_category_id", "created_at", "updated_at") VALUES
    ('Finance', 'Finans', NULL, NOW(), NOW()),
    ('Food & Drink', 'Mat & Dryck', NULL, NOW(), NOW()),
    ('Leisure', 'Fritid', NULL, NOW(), NOW()),
    ('Culture', 'Kultur', NULL, NOW(), NOW()),
    ('Health', 'Hälsa och Vård', NULL, NOW(), NOW()),
    ('Shopping', 'Affär', NULL, NOW(), NOW()),
    ('Education', 'Utbildning', NULL, NOW(), NOW()),
    ('Sport', 'Sport', NULL, NOW(), NOW()),
    ('Accommodation', 'Boende och Hotell', NULL, NOW(), NOW()),
    ('Transport', 'Transport', NULL, NOW(), NOW()),
    ('Authorities', 'Myndigheter och Service', NULL, NOW(), NOW()),
    ('Tourism', 'Turism', NULL, NOW(), NOW()),
    ('Toilets', 'Toaletter', NULL, NOW(), NOW()),
    ('Other', 'Övrigt', NULL, NOW(), NOW());

-- Insert child categories for demonstration
INSERT INTO "public"."place_categories" ("name", "name_sv", "parent_category_id", "created_at", "updated_at") VALUES
    ('ATM', 'Bankomat', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Finance'), NOW(), NOW()),
    ('Bank', 'Bank', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Finance'), NOW(), NOW()),
    ('Bar/Pub', 'Bar/Pub', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Restaurant', 'Restaurang', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW());

-- Places table
CREATE TABLE "public"."places" (
    "place_id" BIGINT NOT NULL PRIMARY KEY,
    "external_id" TEXT UNIQUE,
    "name" TEXT NOT NULL,
    "location" GEOMETRY(Point, 4326) NOT NULL,
    "category_id" BIGINT REFERENCES public.place_categories(category_id),
    "source" "public"."entity_data_source" NOT NULL,
    "is_active" BOOLEAN DEFAULT false,
    "release_batch" TEXT,
    "created_by" uuid REFERENCES "auth"."users"("id") ON DELETE SET NULL,  -- Store creator here
    "created_at" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" TIMESTAMP WITH TIME ZONE DEFAULT (now() AT TIME ZONE 'utc'::text),
    "is_overridden" BOOLEAN DEFAULT FALSE,
    "overridden_fields" JSONB
);

-- Place entrances table
CREATE TABLE "public"."entrances" (
    "entrance_id" BIGINT NOT NULL PRIMARY KEY,
    "place_id" BIGINT NOT NULL REFERENCES public.places(place_id),
    "entrance_type_id" integer NOT NULL,
    "location" geometry,
    "accessibility_info" jsonb,
    "created_by" uuid REFERENCES "auth"."users"("id") ON DELETE SET NULL,
    "created_at" timestamp with time zone DEFAULT now(),
    "updated_at" timestamp with time zone DEFAULT now()
);

-- Place entrance photos table
CREATE TABLE "public"."entrance_photos" (
    "photo_id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "place_id" BIGINT REFERENCES public.places(place_id),
    "photo_filename" character varying,
    "description" text,
    "entrance_id" integer REFERENCES public.entrances(entrance_id),
    "uploaded_by" uuid REFERENCES "auth"."users"("id") ON DELETE SET NULL,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text)
);

-- Entity changes staging table
CREATE TABLE "public"."entity_changes_staging" (
    "id" serial PRIMARY KEY,
    "entity_type" "public"."entity_type" NOT NULL,
    "action_type" "public"."entity_changes_action_type" NOT NULL,
    "change_data" jsonb NOT NULL,  -- Entity-specific data
    "status" "public"."entity_changes_staging_status" NOT NULL DEFAULT 'pending',
    "submitted_by" uuid REFERENCES "auth"."users"("id") ON DELETE SET NULL,  -- Submitter
    "submitted_at" timestamp with time zone NOT NULL DEFAULT now(),
    "reviewed_by" uuid REFERENCES "auth"."users"("id") ON DELETE SET NULL,  -- Reviewer
    "reviewed_at" timestamp with time zone,
    "source" "public"."entity_data_source" NOT NULL,
    "__is_retired" boolean DEFAULT false
);


-- Entity changes events table
CREATE TABLE "public"."entity_changes_events" (
    "id" serial PRIMARY KEY,
    "entity_id" text NOT NULL,
    "entity_type" "public"."entity_type" NOT NULL,
    "action_type" "public"."entity_changes_action_type" NOT NULL,
    "user_id" uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    "event_timestamp" timestamp with time zone DEFAULT now(),
    "change_data" jsonb,
    "comments" text  -- Optional: Any additional comments or information
);

CREATE TABLE "public"."entity_overrides" (
    "override_id" SERIAL PRIMARY KEY,
    "entity_type" "public"."entity_type" NOT NULL,
    "entity_id" BIGINT NOT NULL,
    "overridden_fields" JSONB NOT NULL,
    "override_date" TIMESTAMP WITH TIME ZONE DEFAULT now(),
    "expiry_date" TIMESTAMP WITH TIME ZONE,
    "overridden_by" UUID REFERENCES auth.users(id),
    "notes" TEXT
);

-- Place OSM tag to category mapping
CREATE TABLE "public"."osm_tag_to_place_category" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "tag_key" text NOT NULL,
    "tag_value" text NOT NULL,
    "category_id" bigint,
    "priority" integer NOT NULL DEFAULT 0,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text)
);

-- Entrance types table
CREATE TABLE "public"."entrance_types" (
    "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "name" text NOT NULL,
    "name_sv" text NOT NULL,
    "description" text,
    "description_sv" text,
    "is_active" boolean NOT NULL DEFAULT true,
    "max_per_place" integer DEFAULT NULL,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text)
);

CREATE TABLE public.entity_json_schemas (
  entity_type "public"."entity_type" PRIMARY KEY,
  json_schema jsonb NOT NULL
);

-- Insert JSON schemas for entity types
INSERT INTO public.entity_json_schemas (entity_type, json_schema) VALUES
  ('place'::"public"."entity_type", '{
    "type": "object",
    "properties": {
      "name": { "type": "string" },
      "location": { 
        "type": "object", 
        "properties": {
          "coordinates": {
            "type": "object",
            "properties": {
              "lat": { "type": "number" },
              "long": { "type": "number" }
            },
            "required": ["lat", "long"]
          }
        },
        "required": ["coordinates"]
      },
      "category_id": { "type": "integer" },
      "source": { "type": "string" },
      "external_id": { "type": "string" },
      "submitted_by": { "type": "string", "format": "uuid" },
      "is_active": { "type": "boolean" },
      "overridden_fields": { "type": "object" }
    },
    "required": ["name", "location", "category_id", "source", "submitted_by"]
  }'::jsonb),

  ('entrance'::"public"."entity_type", '{
    "type": "object",
    "properties": {
      "place_id": { "type": "integer" },
      "entrance_type_id": { "type": "integer" },
      "photo_filename": { "type": "string" },
      "location": { 
        "type": "object", 
        "properties": {
          "coordinates": {
            "type": "object",
            "properties": {
              "lat": { "type": "number" },
              "long": { "type": "number" }
            },
            "required": ["lat", "long"]
          }
        },
        "required": ["coordinates"] 
      },
      "accessibility_info": { "type": "object" },
      "source": { "type": "string" },
      "submitted_by": { "type": "string", "format": "uuid" }
    },
    "required": ["place_id", "entrance_type_id", "location", "source", "submitted_by"]
  }'::jsonb),

  ('photo'::"public"."entity_type", '{
    "type": "object",
    "properties": {
      "photo_filename": { "type": "string" },
      "description": { "type": "string" },
      "place_id": { "type": "integer" },
      "submitted_by": { "type": "string", "format": "uuid" },
      "source": { "type": "string" }
    },
    "required": ["photo_filename", "place_id", "submitted_by", "source"]
  }'::jsonb);



-- Create a composite index for efficient lookups
CREATE INDEX idx_entity_overrides_entity ON public.entity_overrides(entity_type, entity_id);

-- Additional indexes for common query patterns
CREATE INDEX idx_entity_overrides_expiry_date ON public.entity_overrides(expiry_date);
CREATE INDEX idx_entity_overrides_overridden_by ON public.entity_overrides(overridden_by);

-- Indexes for places table
CREATE INDEX idx_places_category_id ON public.places(category_id);
CREATE INDEX idx_places_external_id ON public.places(external_id);
CREATE INDEX idx_places_source ON public.places(source);
CREATE INDEX idx_places_is_active ON public.places(is_active);
CREATE INDEX idx_places_created_by ON public.places(created_by);
CREATE INDEX idx_places_location ON public.places USING GIST(location);

-- Indexes for entrances table
CREATE INDEX idx_entrances_place_id ON public.entrances(place_id);
CREATE INDEX idx_entrances_entrance_type_id ON public.entrances(entrance_type_id);
CREATE INDEX idx_entrances_created_by ON public.entrances(created_by);
CREATE INDEX idx_entrances_location ON public.entrances USING GIST(location);

-- Indexes for entrance_photos table
CREATE INDEX idx_entrance_photos_place_id ON public.entrance_photos(place_id);
CREATE INDEX idx_entrance_photos_entrance_id ON public.entrance_photos(entrance_id);
CREATE INDEX idx_entrance_photos_uploaded_by ON public.entrance_photos(uploaded_by);

-- Indexes for entity_changes_staging table
CREATE INDEX idx_entity_changes_staging_entity_type ON public.entity_changes_staging(entity_type);
CREATE INDEX idx_entity_changes_staging_action_type ON public.entity_changes_staging(action_type);
CREATE INDEX idx_entity_changes_staging_status ON public.entity_changes_staging(status);
CREATE INDEX idx_entity_changes_staging_submitted_by ON public.entity_changes_staging(submitted_by);
CREATE INDEX idx_entity_changes_staging_reviewed_by ON public.entity_changes_staging(reviewed_by);
CREATE INDEX idx_entity_changes_staging_source ON public.entity_changes_staging(source);

-- Indexes for entity_changes_events table
CREATE INDEX idx_entity_changes_events_entity_id ON public.entity_changes_events(entity_id);
CREATE INDEX idx_entity_changes_events_entity_type ON public.entity_changes_events(entity_type);
CREATE INDEX idx_entity_changes_events_action_type ON public.entity_changes_events(action_type);
CREATE INDEX idx_entity_changes_events_user_id ON public.entity_changes_events(user_id);
CREATE INDEX idx_entity_changes_events_event_timestamp ON public.entity_changes_events(event_timestamp);

-- Indexes for osm_tag_to_place_category table
CREATE INDEX idx_osm_tag_to_place_category_tag_key ON public.osm_tag_to_place_category(tag_key);
CREATE INDEX idx_osm_tag_to_place_category_tag_value ON public.osm_tag_to_place_category(tag_value);
CREATE INDEX idx_osm_tag_to_place_category_category_id ON public.osm_tag_to_place_category(category_id);

-- Indexes for entrance_types table
CREATE INDEX idx_entrance_types_is_active ON public.entrance_types(is_active);

-- General functions
CREATE OR REPLACE FUNCTION public.check_email_exists(email character varying)
RETURNS boolean
LANGUAGE plpgsql
STABLE SECURITY DEFINER
SET search_path TO 'public'
AS $function$
DECLARE
    val VARCHAR;
BEGIN
    SELECT u.email INTO val FROM users u
    WHERE u.email = LOWER($1);  -- Use function argument explicitly to avoid ambiguity

    IF FOUND THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$function$;

-- Create view for consolidated places data for frontend and Martin
CREATE MATERIALIZED VIEW public.places_view AS
WITH entrance_details AS (
  -- Aggregate entrance information into a JSON array
  SELECT 
    pe.place_id,
    json_agg(
      json_build_object(
        'entrance_id', pe.entrance_id,
        'location', ST_AsGeoJSON(pe.location)::json,
        'accessibility_info', pe.accessibility_info,
        'created_at', pe.created_at,
        'updated_at', pe.updated_at,
        'images', (
          SELECT json_agg(
            json_build_object(
              'photo_id', pep.photo_id,
              'photo_url', pep.photo_filename,
              'description', pep.description
            )
          )
          FROM public.entrance_photos pep
          WHERE pep.entrance_id = pe.entrance_id
        )
      )
    ) AS entrances
  FROM public.entrances pe
  GROUP BY pe.place_id
),
place_with_overrides AS (
  SELECT 
    p.place_id,
    COALESCE(eo.overridden_fields->>'name', p.name) AS name,
    COALESCE(
      ST_SetSRID(ST_GeomFromGeoJSON((eo.overridden_fields->>'location')::text), 4326),
      p.location
    ) AS location,
    COALESCE((eo.overridden_fields->>'category_id')::BIGINT, p.category_id) AS category_id,
    p.source,
    COALESCE((eo.overridden_fields->>'is_active')::BOOLEAN, p.is_active, TRUE) AS is_active,
    p.created_at,
    p.updated_at,
    p.is_overridden,
    p.overridden_fields
  FROM public.places p
  LEFT JOIN public.entity_overrides eo ON eo.entity_type = 'place'::"public"."entity_type" AND eo.entity_id = p.place_id
  WHERE (eo.expiry_date IS NULL OR eo.expiry_date > NOW()) OR eo.entity_id IS NULL
)
SELECT 
  pwo.place_id,
  pwo.name,
  pwo.location,
  ST_Y(pwo.location::geometry) AS lat,
  ST_X(pwo.location::geometry) AS long,
  CASE
    WHEN pc.parent_category_id IS NOT NULL THEN pwo.category_id
    ELSE NULL
  END AS category_id,
  CASE
    WHEN pc.parent_category_id IS NOT NULL THEN pc.name
    ELSE NULL
  END AS category_name,
  CASE
    WHEN pc.parent_category_id IS NOT NULL THEN pc.name_sv
    ELSE NULL
  END AS category_name_sv,
  CASE
    WHEN pc.parent_category_id IS NOT NULL THEN pc.parent_category_id
    ELSE pwo.category_id
  END AS parent_category_id,
  CASE
    WHEN pc.parent_category_id IS NOT NULL THEN pc2.name
    ELSE pc.name
  END AS parent_category_name,
  CASE
    WHEN pc.parent_category_id IS NOT NULL THEN pc2.name_sv
    ELSE pc.name_sv
  END AS parent_category_name_sv,
  pwo.source,
  pwo.is_active,
  pwo.created_at,
  pwo.updated_at,
  pwo.is_overridden,
  pwo.overridden_fields,
  COALESCE(ed.entrances, '[]'::json) AS entrances -- Get entrance JSON data
FROM place_with_overrides pwo
LEFT JOIN public.place_categories pc ON pwo.category_id = pc.category_id
LEFT JOIN public.place_categories pc2 ON pc.parent_category_id = pc2.category_id
LEFT JOIN entrance_details ed ON pwo.place_id = ed.place_id
WHERE pwo.is_active = true;  -- Only include active places

-- Create a unique index on the materialized view
CREATE UNIQUE INDEX idx_places_view_place_id ON public.places_view (place_id);

-- Create indexes for the materialized view
CREATE INDEX idx_places_view_category_id ON public.places_view(category_id);
CREATE INDEX idx_places_view_parent_category_id ON public.places_view(parent_category_id);
CREATE INDEX idx_places_view_source ON public.places_view(source);
CREATE INDEX idx_places_view_is_active ON public.places_view(is_active);
CREATE INDEX idx_places_view_created_at ON public.places_view(created_at);
CREATE INDEX idx_places_view_updated_at ON public.places_view(updated_at);
CREATE INDEX idx_places_view_location ON public.places_view USING GIST(location);
CREATE INDEX idx_places_view_name ON public.places_view(name);
CREATE INDEX idx_places_view_category_name ON public.places_view(category_name);
CREATE INDEX idx_places_view_category_name_sv ON public.places_view(category_name_sv);
CREATE INDEX idx_places_view_parent_category_name ON public.places_view(parent_category_name);
CREATE INDEX idx_places_view_parent_category_name_sv ON public.places_view(parent_category_name_sv);
CREATE INDEX idx_places_view_lat ON public.places_view(lat);
CREATE INDEX idx_places_view_long ON public.places_view(long);


CREATE OR REPLACE VIEW public.entrances_view AS
WITH verified_entrances AS (
  SELECT 
    se.entrance_id::text AS entrance_id,
    se.place_id,
    se.entrance_type_id,
    et.name AS entrance_type_name,
    et.name_sv AS entrance_type_name_sv,
    et.description AS entrance_type_description,
    et.description_sv AS entrance_type_description_sv,
    se.location,
    se.accessibility_info,
    json_agg(json_build_object(
      'photo_id', pep.photo_id,
      'photo_filename', pep.photo_filename,
      'description', pep.description
    )) FILTER (WHERE pep.photo_id IS NOT NULL) AS photos,
    'approved' AS status,
    se.created_by,
    se.created_at,
    se.updated_at
  FROM public.entrances se
  JOIN public.entrance_types et ON et.id = se.entrance_type_id
  LEFT JOIN public.entrance_photos pep ON pep.entrance_id = se.entrance_id
  GROUP BY se.entrance_id, se.place_id, se.entrance_type_id, et.name, et.name_sv, et.description, et.description_sv, se.location, se.accessibility_info, se.created_by, se.created_at, se.updated_at
),
pending_entrances AS (
  SELECT 
    ecs.id::text AS entrance_id,
    (ecs.change_data->>'place_id')::bigint AS place_id,
    (ecs.change_data->>'entrance_type_id')::integer AS entrance_type_id,
    et.name AS entrance_type_name,
    et.name_sv AS entrance_type_name_sv,
    et.description AS entrance_type_description,
    et.description_sv AS entrance_type_description_sv,
    ST_SetSRID(ST_MakePoint(
      (ecs.change_data->'location'->>'long')::float,
      (ecs.change_data->'location'->>'lat')::float
    ), 4326) AS location,
    (ecs.change_data->>'accessibility_info')::jsonb AS accessibility_info,
    json_build_array(json_build_object(
      'photo_id', NULL,
      'photo_filename', ecs.change_data->>'photo_filename',
      'description', NULL
    )) AS photos,
    ecs.status::text,
    ecs.submitted_by AS created_by,
    ecs.submitted_at AS created_at,
    ecs.submitted_at AS updated_at
  FROM public.entity_changes_staging ecs
  LEFT JOIN public.entrance_types et ON et.id = (ecs.change_data->>'entrance_type_id')::integer
  WHERE ecs.entity_type = 'entrance'::"public"."entity_type"
)
-- Combine verified and pending entrances
SELECT * FROM verified_entrances
UNION ALL
SELECT * FROM pending_entrances;

-- end entrances_view



-- Functions

CREATE OR REPLACE FUNCTION public.insert_place_staging(
  p_change_data JSONB,
  p_auto_approve BOOLEAN DEFAULT FALSE
) RETURNS BIGINT AS $$
DECLARE
  v_source public.entity_data_source;
  v_staging_id BIGINT;
  v_json_schema JSONB;
  v_is_valid BOOLEAN;
  v_submitted_by UUID;
BEGIN
  -- Extract submitted_by from p_change_data
  v_submitted_by := (p_change_data->>'submitted_by')::UUID;

  -- Ensure submitted_by is provided
  IF v_submitted_by IS NULL THEN
    RAISE EXCEPTION 'submitted_by must be provided in change_data';
  END IF;

  -- Convert source to entity_data_source enum
  v_source := (p_change_data->>'source')::public.entity_data_source;

  -- Check if the provided source is valid
  IF v_source NOT IN ('osm', 'user', 'external') THEN
    RAISE EXCEPTION 'Invalid source value: %. Valid values are: osm, user, external.', v_source;
  END IF;

  -- If source is 'osm', external_id should be provided, otherwise it's NULL
  IF v_source = 'osm' AND (p_change_data->>'external_id') IS NULL THEN
      RAISE EXCEPTION 'External ID must be provided for OSM places.';
  END IF;

  -- Fetch the schema for the place entity type
  SELECT json_schema INTO v_json_schema
  FROM public.entity_json_schemas
  WHERE entity_type = 'place'::"public"."entity_type";

  -- Validate the change_data against the schema
  SELECT extensions.json_matches_schema(v_json_schema::json, p_change_data::json) INTO v_is_valid;

  -- If validation fails, raise an error
  IF NOT v_is_valid THEN
    RAISE EXCEPTION 'Invalid change_data for entity_type place, expected %, got %', v_json_schema, p_change_data;
  END IF;

  -- Insert into entity_changes_staging table for approval without generating place_id
  INSERT INTO public.entity_changes_staging (
    entity_type,
    action_type,
    change_data,
    status,
    source,
    submitted_by
  ) VALUES (
    'place',
    'add',
    p_change_data,
    'pending'::"public"."entity_changes_staging_status",
    v_source,
    v_submitted_by
  ) RETURNING id INTO v_staging_id;

  -- Log this action in the event/audit table
  INSERT INTO public.entity_changes_events (
    entity_id,
    entity_type,
    action_type,
    user_id,
    change_data
  ) VALUES (
    v_staging_id::text,
    'place'::"public"."entity_type",
    'add'::"public"."entity_changes_action_type",
    v_submitted_by,
    p_change_data
  );

  IF p_auto_approve THEN
    PERFORM public.approve_entity(v_staging_id, 'place', v_submitted_by);
  END IF;

  RETURN v_staging_id;
END;
$$ LANGUAGE plpgsql;


--

CREATE OR REPLACE FUNCTION public.insert_place_staging_osm(
  p_osm_id BIGINT,
  p_submitted_by UUID,
  p_auto_approve BOOLEAN DEFAULT FALSE
) RETURNS BIGINT AS $$
DECLARE
  v_osm_id BIGINT;
  v_name TEXT;
  v_tags HSTORE;
  v_category_id BIGINT;
  v_location GEOMETRY(Point, 4326);
  v_staging_id BIGINT;
  v_change_data JSONB;
BEGIN
  -- Fetch the OSM data
  SELECT osm_id, name, tags, geom
  INTO v_osm_id, v_name, v_tags, v_location
  FROM osm_import.osm_poi_places
  WHERE osm_id = p_osm_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'OSM point with ID % not found', p_osm_id;
  END IF;

  v_category_id := public.get_category_id_from_osm_tags(v_tags);

  -- If no category is found, use a default category
  IF v_category_id IS NULL THEN
    SELECT category_id INTO v_category_id
    FROM public.place_categories
    WHERE name = 'Other'
    LIMIT 1;
  END IF;

  -- Checks that the place does not already exist
  IF EXISTS (SELECT 1 FROM public.places WHERE external_id = p_osm_id::TEXT AND source = 'osm') THEN
    RAISE EXCEPTION 'Place with external ID % already exists', p_osm_id;
  END IF;

  -- Prepare change data
  v_change_data := jsonb_build_object(
    'name', v_name,
    'location', jsonb_build_object(
      'coordinates', json_build_object(
        'lat', ST_Y(v_location),
        'long', ST_X(v_location)
      )
    ),
    'category_id', v_category_id,
    'source', 'osm',
    'external_id', p_osm_id::TEXT,
    'submitted_by', p_submitted_by::TEXT
  );

  -- Call the insert_place_staging function
  v_staging_id := public.insert_place_staging(
    p_change_data := v_change_data,
    p_auto_approve := p_auto_approve
  );

  RETURN v_staging_id;
END;
$$ LANGUAGE plpgsql;
--

CREATE OR REPLACE FUNCTION public.insert_entrance_staging(
  p_change_data JSONB,
  p_auto_approve BOOLEAN DEFAULT FALSE
) RETURNS VOID AS $$
DECLARE
  v_source public.entity_data_source;
  v_json_schema JSONB;
  v_is_valid BOOLEAN;
  v_submitted_by UUID;
  v_staging_id BIGINT;
BEGIN
  -- Extract submitted_by from p_change_data
  v_submitted_by := (p_change_data->>'submitted_by')::UUID;

  -- Ensure submitted_by is provided
  IF v_submitted_by IS NULL THEN
    RAISE EXCEPTION 'submitted_by must be provided in change_data';
  END IF;

  -- Fetch the schema for the entrance entity type
  SELECT json_schema INTO v_json_schema
  FROM public.entity_json_schemas
  WHERE entity_type = 'entrance'::"public"."entity_type";

  -- Validate the change_data against the schema
  SELECT extensions.json_matches_schema(v_json_schema::json, p_change_data::json) INTO v_is_valid;

  -- If validation fails, raise an error
  IF NOT v_is_valid THEN
    RAISE EXCEPTION 'Invalid change_data for entity_type entrance, expected %, got %', v_json_schema, p_change_data;
  END IF;

  -- Determine the source (assuming it's provided in p_change_data, otherwise default to 'user')
  v_source := COALESCE((p_change_data->>'source')::public.entity_data_source, 'user'::public.entity_data_source);

  -- Insert into entity_changes_staging table for approval
  INSERT INTO public.entity_changes_staging (
    entity_type,
    action_type,
    change_data,
    status,
    source,
    submitted_by
  ) VALUES (
    'entrance'::"public"."entity_type",
    'add'::"public"."entity_changes_action_type",
    p_change_data,
    'pending'::"public"."entity_changes_staging_status",
    v_source,
    v_submitted_by
  ) RETURNING id INTO v_staging_id;

  -- Log this action in the event/audit table
  INSERT INTO public.entity_changes_events (
    entity_id,
    entity_type,
    action_type,
    user_id,
    change_data
  ) VALUES (
    v_staging_id::text,
    'entrance'::"public"."entity_type",
    'add'::"public"."entity_changes_action_type",
    v_submitted_by,
    p_change_data

  );

  IF p_auto_approve THEN
    PERFORM public.approve_entity(v_staging_id, 'entrance', v_submitted_by);
  END IF;
END;
$$ LANGUAGE plpgsql;

--


CREATE FUNCTION "public"."refresh_places_view"()
RETURNS TRIGGER AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.places_view;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--


CREATE OR REPLACE FUNCTION public.approve_entity(
  p_entity_id BIGINT,
  p_entity_type TEXT,
  p_reviewed_by UUID
) RETURNS VOID AS $$
DECLARE
  v_change_data JSONB;
  v_location GEOMETRY(Point, 4326);
  v_new_place_id BIGINT;
  v_new_entrance_id BIGINT;
  v_submitted_by UUID;
  v_source public.entity_data_source;
  v_entity_type public.entity_type;
BEGIN
  -- Convert p_entity_type to entity_type enum
  v_entity_type := p_entity_type::public.entity_type;

  -- Fetch the pending change data from staging
  SELECT change_data, submitted_by, source INTO v_change_data, v_submitted_by, v_source
  FROM public.entity_changes_staging 
  WHERE id = p_entity_id AND entity_type = v_entity_type AND status = 'pending'::"public"."entity_changes_staging_status";

  IF NOT FOUND THEN
    RAISE EXCEPTION 'No pending % entity found with ID: %', p_entity_type, p_entity_id;
  END IF;

  IF v_entity_type = 'place'::"public"."entity_type" THEN
    -- Generate a new place ID using the sequence
    v_new_place_id := nextval('places_place_id_seq'::regclass);
    
    -- Create the location point
    v_location := ST_SetSRID(ST_MakePoint(
      (v_change_data->'location'->'coordinates'->>'long')::float,
      (v_change_data->'location'->'coordinates'->>'lat')::float
    ), 4326);

    -- Insert the approved place into the actual places table
    INSERT INTO public.places (
      place_id, external_id, name, location, category_id, source, created_by, is_active, created_at
    ) 
    VALUES (
      v_new_place_id,
      v_change_data->>'external_id',
      v_change_data->>'name',
      v_location,
      (v_change_data->>'category_id')::BIGINT,
      v_source,
      v_submitted_by,
      TRUE,
      NOW()
    );

  ELSIF v_entity_type = 'entrance'::"public"."entity_type" THEN
    v_new_entrance_id := nextval('entrances_entrance_id_seq'::regclass);
    -- Insert the approved entrance into the entrances table
    INSERT INTO public.entrances (
      entrance_id, place_id, entrance_type_id, location, accessibility_info, created_by, created_at
    ) 
    VALUES (
      v_new_entrance_id,
      (v_change_data->>'place_id')::BIGINT,
      (v_change_data->>'entrance_type_id')::INTEGER,
      ST_SetSRID(ST_MakePoint(
        (v_change_data->'location'->'coordinates'->>'long')::float,
        (v_change_data->'location'->'coordinates'->>'lat')::float
      ), 4326),
      (v_change_data->>'accessibility_info')::jsonb,
      v_submitted_by,
      NOW()
    );
  END IF;

  -- Mark the entity as approved in the staging table
  UPDATE public.entity_changes_staging
  SET status = 'approved'::"public"."entity_changes_staging_status", reviewed_by = p_reviewed_by, reviewed_at = NOW(), __is_retired = TRUE
  WHERE id = p_entity_id AND entity_type = v_entity_type;

  -- Log this approval action in the event/audit table
  INSERT INTO public.entity_changes_events (
    entity_id,
    entity_type,
    action_type,
    user_id,
    change_data
  ) VALUES (
    CASE 
      WHEN v_entity_type = 'place'::"public"."entity_type" THEN v_new_place_id::text
      WHEN v_entity_type = 'entrance'::"public"."entity_type" THEN v_new_entrance_id::text
      ELSE p_entity_id::text
    END,
    v_entity_type,
    'approve'::"public"."entity_changes_action_type",
    p_reviewed_by,
    v_change_data
  );
  
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION public.get_entrance_type_counts(p_place_id BIGINT)
RETURNS TABLE (entrance_type_id INTEGER, count BIGINT) 
LANGUAGE SQL
AS $$
    SELECT entrance_type_id, COUNT(*) as count
    FROM entrances
    WHERE place_id = p_place_id
    GROUP BY entrance_type_id;
$$;

CREATE OR REPLACE FUNCTION public.get_category_id_from_osm_tags(tags hstore)
RETURNS integer
LANGUAGE plpgsql
STABLE
AS $function$
DECLARE
    cat_id INTEGER;
    other_category_id INTEGER;
    current_key TEXT;
    current_value TEXT;
BEGIN
    -- First, try to find an exact match
    SELECT category_id INTO cat_id
    FROM osm_tag_to_place_category
    WHERE (tag_key, tag_value) IN (SELECT key, value FROM each(tags))
    ORDER BY priority DESC
    LIMIT 1;

    -- If no exact match, try wildcard matches
    IF cat_id IS NULL THEN
        FOR current_key, current_value IN SELECT key, value FROM each(tags)
        LOOP
            -- Try to match the specific key with a wildcard value
            SELECT category_id INTO cat_id
            FROM osm_tag_to_place_category
            WHERE tag_key = current_key AND tag_value = '*'
            ORDER BY priority DESC
            LIMIT 1;

            EXIT WHEN cat_id IS NOT NULL;
        END LOOP;
    END IF;

    -- If a category is found, log it and return
    IF cat_id IS NOT NULL THEN
        RAISE NOTICE 'Category found: %', cat_id;
        RETURN cat_id;
    END IF;

    -- If no category is found, return the 'Other' category
    SELECT category_id INTO other_category_id
    FROM place_categories
    WHERE name = 'Other'
    LIMIT 1;

    IF other_category_id IS NULL THEN
        RAISE EXCEPTION 'Default "Other" category not found';
    END IF;

    RAISE NOTICE 'No specific category found, using "Other" category: %', other_category_id;
    RETURN other_category_id;
END;
$function$;

-- Enable RLS for all tables
ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."place_categories" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."places" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entrances" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entrance_photos" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entity_changes_staging" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entity_changes_events" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entity_overrides" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."osm_tag_to_place_category" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entrance_types" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entity_json_schemas" ENABLE ROW LEVEL SECURITY;

-- RLS Policies for users table
CREATE POLICY "Users can view their own profile" ON "public"."users"
FOR SELECT TO authenticated
USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile" ON "public"."users"
FOR UPDATE TO authenticated
USING (auth.uid() = id);

-- RLS Policies for place_categories table
CREATE POLICY "Allow read access for all users" ON "public"."place_categories"
FOR SELECT TO public
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."place_categories"
FOR INSERT TO authenticated
WITH CHECK (true);

CREATE POLICY "Allow update for authenticated users" ON "public"."place_categories"
FOR UPDATE TO authenticated
USING (true);

-- RLS Policies for places table
CREATE POLICY "Allow read access for all users" ON "public"."places"
FOR SELECT TO public
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."places"
FOR INSERT TO authenticated
WITH CHECK (true);

CREATE POLICY "Allow update for authenticated users" ON "public"."places"
FOR UPDATE TO authenticated
USING (true);

-- RLS Policies for entrances table
CREATE POLICY "Allow read access for all users" ON "public"."entrances"
FOR SELECT TO public
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."entrances"
FOR INSERT TO authenticated
WITH CHECK (true);

CREATE POLICY "Allow update for authenticated users" ON "public"."entrances"
FOR UPDATE TO authenticated
USING (true);

-- RLS Policies for entrance_photos table
CREATE POLICY "Allow read access for all users" ON "public"."entrance_photos"
FOR SELECT TO public
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."entrance_photos"
FOR INSERT TO authenticated
WITH CHECK (true);

CREATE POLICY "Allow update for authenticated users" ON "public"."entrance_photos"
FOR UPDATE TO authenticated
USING (true);

-- RLS Policies for entity_changes_staging table
CREATE POLICY "Allow read access for authenticated users" ON "public"."entity_changes_staging"
FOR SELECT TO authenticated
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."entity_changes_staging"
FOR INSERT TO authenticated
WITH CHECK ((auth.uid() = (change_data->>'submitted_by')::uuid) OR (auth.role() = 'admin'));

CREATE POLICY "Allow update for authenticated users" ON "public"."entity_changes_staging"
FOR UPDATE TO authenticated
USING (true);

-- RLS Policies for entity_changes_events table
CREATE POLICY "Allow read access for authenticated users" ON "public"."entity_changes_events"
FOR SELECT TO authenticated
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."entity_changes_events"
FOR INSERT TO authenticated
WITH CHECK (true);

-- RLS Policies for entity_overrides table
CREATE POLICY "Allow read access for authenticated users" ON "public"."entity_overrides"
FOR SELECT TO authenticated
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."entity_overrides"
FOR INSERT TO authenticated
WITH CHECK (true);

CREATE POLICY "Allow update for authenticated users" ON "public"."entity_overrides"
FOR UPDATE TO authenticated
USING (true);

-- RLS Policies for osm_tag_to_place_category table
CREATE POLICY "Allow read access for all users" ON "public"."osm_tag_to_place_category"
FOR SELECT TO public
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."osm_tag_to_place_category"
FOR INSERT TO authenticated
WITH CHECK (true);

CREATE POLICY "Allow update for authenticated users" ON "public"."osm_tag_to_place_category"
FOR UPDATE TO authenticated
USING (true);

-- RLS Policies for entrance_types table
CREATE POLICY "Allow read access for all users" ON "public"."entrance_types"
FOR SELECT TO public
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."entrance_types"
FOR INSERT TO authenticated
WITH CHECK (true);

CREATE POLICY "Allow update for authenticated users" ON "public"."entrance_types"
FOR UPDATE TO authenticated
USING (true);

-- RLS Policies for entity_json_schemas table
CREATE POLICY "Allow read access for all users" ON "public"."entity_json_schemas"
FOR SELECT TO public
USING (true);

CREATE POLICY "Allow insert for authenticated users" ON "public"."entity_json_schemas"
FOR INSERT TO authenticated
WITH CHECK (true);

CREATE POLICY "Allow update for authenticated users" ON "public"."entity_json_schemas"
FOR UPDATE TO authenticated
USING (true);

set check_function_bodies = off;
