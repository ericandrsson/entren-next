-- Extensions
CREATE EXTENSION IF NOT EXISTS "hstore" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "moddatetime" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "postgis" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "postgres_fdw" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "pg_jsonschema" WITH SCHEMA "extensions";

-- Foreign Data Wrapper setup
CREATE SERVER osm_remote_server FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host '135.181.108.171', dbname 'postgres', port '5433');
CREATE USER MAPPING FOR CURRENT_USER SERVER osm_remote_server OPTIONS (user 'postgres', password 'p4ik5IdbSwQBMaUNBUgashGjZUxBhkN9Autx9R9Yj9VeXNgOIMYzhIuapPKn8ti1');
CREATE SCHEMA IF NOT EXISTS osm_import;
IMPORT FOREIGN SCHEMA public FROM SERVER osm_remote_server INTO osm_import;

-- Custom types
CREATE TYPE "public"."contribution_action" AS ENUM ('ADD', 'UPDATE', 'REPORT', 'PHOTO_UPLOAD');
CREATE TYPE "public"."contribution_status" AS ENUM ('PENDING', 'APPROVED', 'REJECTED');

-- Sequences
CREATE SEQUENCE "public"."user_notifications_notification_id_seq";
CREATE SEQUENCE "public"."place_entrances_id_seq";

-- Tables
CREATE TABLE "public"."users" (
    "id" uuid NOT NULL PRIMARY KEY,
    "email" text,
    "first_name" text,
    "last_name" text
);

CREATE TABLE "public"."user_notifications" (
    "notification_id" integer NOT NULL DEFAULT nextval('user_notifications_notification_id_seq'::regclass) PRIMARY KEY,
    "user_id" uuid,
    "message" text NOT NULL,
    "is_read" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT now()
);

CREATE TABLE "public"."place_categories" (
    "category_id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "name" text NOT NULL,
    "name_sv" text NOT NULL,
    "parent_category_id" bigint,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text)
);

-- After creating the place_categories table, add this:
INSERT INTO "public"."place_categories" ("name", "name_sv", "parent_category_id", "created_at", "updated_at") VALUES
    ('Finance', 'Finans', NULL, NOW(), NOW()),
    ('Food & Drink', 'Mat & Dryck', NULL, NOW(), NOW()),
    ('Leisure', 'Fritid', NULL, NOW(), NOW()),
    ('Culture', 'Kultur', NULL, NOW(), NOW()),
    ('Health', 'Hälsa och Vård', NULL, NOW(), NOW()),
    ('Shopping', 'Affär', NULL, NOW(), NOW()),
    ('Education', 'Utbildning', NULL, NOW(), NOW()),
    ('Sport', 'Sport', NULL, NOW(), NOW()),
    ('Accommodation', 'Boende och Hotell', NULL, NOW(), NOW()),
    ('Transport', 'Transport', NULL, NOW(), NOW()),
    ('Authorities', 'Myndigheter och Service', NULL, NOW(), NOW()),
    ('Tourism', 'Turism', NULL, NOW(), NOW()),
    ('Toilets', 'Toaletter', NULL, NOW(), NOW()),
    ('Other', 'Övrigt', NULL, NOW(), NOW());

-- Then, insert child categories
INSERT INTO "public"."place_categories" ("name", "name_sv", "parent_category_id", "created_at", "updated_at") VALUES
    ('ATM', 'Bankomat', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Finance'), NOW(), NOW()),
    ('Bank', 'Bank', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Finance'), NOW(), NOW()),
    ('Bar/Pub', 'Bar/Pub', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Bakery', 'Bageri', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Restaurant', 'Restaurang', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Burger Restaurant', 'Hamburgerrestaurang', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Pizzeria', 'Pizzeria', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Kebab Shop', 'Kebabrestaurang', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Sushi Bar', 'Sushibar', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Ice Cream Parlor', 'Glasskiosk', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Fast Food', 'Snabbmat', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Coffee Shop', 'Café', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Sandwich Shop', 'Smörgåsbutik', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Gym', 'Gym', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Leisure'), NOW(), NOW()),
    ('Fitness Station', 'Utegym', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Leisure'), NOW(), NOW()),
    ('Swimming Pool', 'Simhall', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Leisure'), NOW(), NOW()),
    ('Playground', 'Lekplats', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Leisure'), NOW(), NOW());

    
CREATE TABLE "public"."place_osm_tag_to_category" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "tag_key" text NOT NULL,
    "tag_value" text NOT NULL,
    "category_id" bigint,
    "priority" integer NOT NULL DEFAULT 0,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text)
);

CREATE TABLE "public"."entrance_types" (
    "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "name" text NOT NULL,
    "name_sv" text NOT NULL,
    "description" text,
    "description_sv" text,
    "is_active" boolean NOT NULL DEFAULT true,
    "max_per_place" integer DEFAULT NULL,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text)
);

CREATE TABLE "public"."custom_places" (
    "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "name" character varying(255),
    "location" geometry(Point,4326),
    "category_id" bigint,
    "user_id" uuid,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text)
);

-- Remove the places_place_id_seq sequence as it's no longer needed
DROP SEQUENCE IF EXISTS "public"."places_place_id_seq";

CREATE TABLE "public"."place_entrances" (
    "entrance_id" integer NOT NULL DEFAULT nextval('place_entrances_id_seq'::regclass) PRIMARY KEY,
    "place_id" TEXT NOT NULL,
    "entrance_type_id" integer NOT NULL,
    "location" geometry,
    "accessibility_info" jsonb,
    "created_at" timestamp with time zone DEFAULT now(),
    "updated_at" timestamp with time zone DEFAULT now()
);


CREATE TABLE "public"."place_entrance_photos" (
    "photo_id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "place_id" TEXT,
    "user_id" uuid,
    "photo_url" character varying,
    "description" text,
    "entrance_id" integer,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text)
);


CREATE TABLE "public"."entity_changes_staging" (
    "id" serial PRIMARY KEY,
    "user_id" uuid NOT NULL,
    "entity_id" text,
    "entity_type" text NOT NULL CHECK (entity_type IN ('place', 'entrance', 'photo')),
    "action_type" text NOT NULL CHECK (action_type IN ('add', 'update', 'delete')),
    "change_data" jsonb NOT NULL,
    "status" text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    "submitted_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone
);

CREATE TABLE "public"."entity_changes_audit " (
    "id" serial PRIMARY KEY,
    "staging_change_id" int,
    "user_id" uuid NOT NULL,
    "entity_id" int NOT NULL,
    "entity_type" text NOT NULL CHECK (entity_type IN ('place', 'entrance', 'photo')),
    "action_type" text NOT NULL CHECK (action_type IN ('add', 'update', 'delete')),
    "change_data" jsonb NOT NULL,
    "status" text NOT NULL CHECK (status IN ('approved', 'rejected')),
    "reviewed_by" uuid,
    "reviewed_at" timestamp NOT NULL,
    "audit_timestamp" timestamp DEFAULT now()
);

CREATE TABLE public.entity_json_schemas (
  entity_type text PRIMARY KEY,
  json_schema jsonb NOT NULL
);

-- Insert schemas for each entity type
INSERT INTO public.entity_json_schemas (entity_type, json_schema) VALUES
  ('place', '{
    "type": "object",
    "properties": {
      "name": { "type": "string" },
      "location": { "type": "object", "properties": { "lat": { "type": "number" }, "long": { "type": "number" } }, "required": ["lat", "long"] },
      "category_id": { "type": "string" }
    },
    "required": ["name", "location", "category_id"]
  }'::jsonb),
  ('entrance', '{
    "type": "object",
    "properties": {
      "entrance_type_id": { "type": "integer" },
      "place_id": { "type": "string" },
      "photo_url": { "type": "string" },
      "location": { "type": "object", "properties": { "lat": { "type": "number" }, "long": { "type": "number" } }, "required": ["lat", "long"] }
    },
    "required": ["entrance_type_id", "location", "photo_url"]
  }'::jsonb),
  ('photo', '{
    "type": "object",
    "properties": {
      "photo_url": { "type": "string" },
      "description": { "type": "string" },
      "place_id": { "type": "string" }
    },
    "required": ["photo_url", "place_id"]
  }'::jsonb);


-- Indexes
CREATE INDEX "idx_place_entrance_photos_place_id" ON public.place_entrance_photos USING btree (place_id);
CREATE INDEX "idx_place_entrance_photos_user_id" ON public.place_entrance_photos USING btree (user_id);
CREATE INDEX "idx_custom_places_category_id" ON public.custom_places USING btree (category_id);
CREATE INDEX "idx_custom_places_location" ON public.custom_places USING gist (location);
CREATE INDEX "idx_entity_changes_staging_user_id" ON public.entity_changes_staging USING btree (user_id);
CREATE INDEX "idx_entity_changes_staging_entity_id" ON public.entity_changes_staging USING btree (entity_id);
CREATE UNIQUE INDEX "unique_name" ON public.place_categories USING btree (name);

-- Foreign Keys
ALTER TABLE "public"."place_osm_tag_to_category" ADD CONSTRAINT "tag_category_mapping_place_category_id_fkey" FOREIGN KEY (category_id) REFERENCES place_categories(category_id) ON UPDATE CASCADE ON DELETE SET NULL;
ALTER TABLE "public"."place_categories" ADD CONSTRAINT "place_categories_parent_category_fkey" FOREIGN KEY (parent_category_id) REFERENCES place_categories(category_id);
ALTER TABLE "public"."place_entrance_photos" ADD CONSTRAINT "place_entrance_photos_entrance_id_fkey" FOREIGN KEY (entrance_id) REFERENCES place_entrances(entrance_id);
ALTER TABLE "public"."custom_places" ADD CONSTRAINT "custom_places_category_id_fkey" FOREIGN KEY (category_id) REFERENCES place_categories(category_id);
ALTER TABLE "public"."custom_places" ADD CONSTRAINT "custom_places_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL;
ALTER TABLE "public"."entity_changes_staging" ADD CONSTRAINT "entity_changes_staging_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id);
ALTER TABLE "public"."entity_changes_audit " ADD CONSTRAINT "entity_changes_audit _staging_change_id_fkey" FOREIGN KEY (staging_change_id) REFERENCES entity_changes_staging(id);
ALTER TABLE "public"."entity_changes_audit " ADD CONSTRAINT "entity_changes_audit _user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id);
ALTER TABLE "public"."entity_changes_audit " ADD CONSTRAINT "entity_changes_audit _reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES users(id);

CREATE OR REPLACE FUNCTION public.check_email_exists(email character varying)
RETURNS boolean
LANGUAGE plpgsql
STABLE SECURITY DEFINER
SET search_path TO 'public'
AS $function$
DECLARE
    val VARCHAR;
BEGIN
    SELECT u.email INTO val FROM users u
    WHERE u.email = LOWER($1);  -- Use function argument explicitly to avoid ambiguity

    IF FOUND THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$function$;

CREATE OR REPLACE FUNCTION public.get_category_id_from_osm_tags(tags hstore)
RETURNS integer
LANGUAGE plpgsql
STABLE
AS $function$
DECLARE
    cat_id INTEGER;
    other_category_id INTEGER;
    current_key TEXT;
    current_value TEXT;
BEGIN
    -- First, try to find an exact match
    SELECT category_id INTO cat_id
    FROM place_osm_tag_to_category
    WHERE (tag_key, tag_value) IN (SELECT key, value FROM each(tags))
    ORDER BY priority DESC
    LIMIT 1;

    -- If no exact match, try wildcard matches
    IF cat_id IS NULL THEN
        FOR current_key, current_value IN SELECT key, value FROM each(tags)
        LOOP
            -- Try to match the specific key with a wildcard value
            SELECT category_id INTO cat_id
            FROM place_osm_tag_to_category
            WHERE tag_key = current_key AND tag_value = '*'
            ORDER BY priority DESC
            LIMIT 1;

            EXIT WHEN cat_id IS NOT NULL;
        END LOOP;
    END IF;

    -- If a category is found, log it and return
    IF cat_id IS NOT NULL THEN
        RAISE NOTICE 'Category found: %', cat_id;
        RETURN cat_id;
    END IF;

    -- If no category found, set it to 'Other'
    SELECT category_id INTO other_category_id 
    FROM place_categories 
    WHERE name = 'Other'
    LIMIT 1;
    
    IF other_category_id IS NULL THEN
        RAISE EXCEPTION 'Other category not found in place_categories';
    END IF;

    RAISE NOTICE 'No specific category found. Using Other category: %', other_category_id;
    RETURN other_category_id;

EXCEPTION
    WHEN too_many_rows THEN
        RAISE EXCEPTION 'Multiple categories found for the given tags. Please refine the mapping.';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error in get_category_id_from_osm_tags: %', SQLERRM;
END;
$function$;


CREATE OR REPLACE FUNCTION public.get_nearest_places(
    user_lat double precision,
    user_long double precision,
    limit_count integer DEFAULT 10,
    max_distance_meters double precision DEFAULT 10000
)
RETURNS TABLE(
    id text,
    name text,
    lat double precision,
    long double precision,
    distance_meters double precision,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    osm_tags jsonb,
    user_id uuid,
    category_name text,
    parent_category_name text
)
LANGUAGE plpgsql
AS $function$
DECLARE
    user_location geometry;
BEGIN
    PERFORM set_config('search_path', 'public, extensions', false);

    -- Create a point geometry from the input latitude and longitude
    user_location := ST_SetSRID(ST_MakePoint(user_long, user_lat), 4326);

    RETURN QUERY
    SELECT 
        v.id,
        v.name::TEXT,
        ST_Y(v.location::geometry) AS lat,
        ST_X(v.location::geometry) AS long,
        ST_Distance(v.location::geography, user_location::geography) AS distance_meters,
        v.created_at,
        v.updated_at,
        v.osm_tags,
        v.user_id,
        v.category_name::TEXT,
        v.parent_category_name::TEXT
    FROM detailed_places_view v
    WHERE ST_DWithin(
        v.location::geography,
        user_location::geography,
        max_distance_meters
    )
    ORDER BY v.location::geography <-> user_location::geography
    LIMIT limit_count;
END;
$function$;

CREATE OR REPLACE FUNCTION public.process_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.users (id, email)
  VALUES (NEW.id, NEW.email);
  RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.get_entrance_type_counts(p_place_id TEXT)
RETURNS TABLE (entrance_type_id INTEGER, count BIGINT) 
LANGUAGE SQL
AS $$
    SELECT entrance_type_id, COUNT(*) as count
    FROM place_entrances
    WHERE place_id = p_place_id
    GROUP BY entrance_type_id;
$$;

-- add_entity_change
CREATE OR REPLACE FUNCTION public.add_entity_change(
  p_user_id UUID,
  p_entity_id TEXT DEFAULT NULL,
  p_entity_type TEXT DEFAULT NULL,
  p_action_type TEXT DEFAULT NULL,
  p_change_data JSONB DEFAULT '{}'::JSONB
)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_entity_change_id INTEGER;
  v_json_schema JSON;
  v_is_valid BOOLEAN;
BEGIN
  -- Check if entity_type and action_type are null
  IF p_entity_type IS NULL THEN
    RAISE EXCEPTION 'entity_type cannot be null';
  END IF;

  IF p_action_type IS NULL THEN
    RAISE EXCEPTION 'action_type cannot be null';
  END IF;

  -- Fetch the schema for the specified entity type
  SELECT json_schema INTO v_json_schema
  FROM public.entity_json_schemas
  WHERE entity_type = p_entity_type;

  -- Validate the change_data against the schema
  SELECT extensions.json_matches_schema(v_json_schema::json, p_change_data::json) INTO v_is_valid;

  -- If validation fails, raise an error
  IF NOT v_is_valid THEN
    RAISE EXCEPTION 'Invalid change_data for entity_type %s, expected %, got %', p_entity_type, v_json_schema, p_change_data;
  END IF;

  -- Start transaction
  BEGIN
    -- Insert into entity_changes_staging
    INSERT INTO entity_changes_staging (
      user_id,
      entity_id,
      entity_type,
      action_type,
      change_data,
      status
    ) VALUES (
      p_user_id,
      p_entity_id,
      p_entity_type,
      p_action_type,
      p_change_data,
      'pending'
    )
    RETURNING id INTO v_entity_change_id;

    -- If we get here, commit the transaction
    RETURN v_entity_change_id;
  EXCEPTION
    WHEN OTHERS THEN
      -- If any error occurs, the transaction will be rolled back automatically
      RAISE;
  END;
END;
$$;
-- end add_entity_change

-- Views
-- detailed_places_view
CREATE MATERIALIZED VIEW public.detailed_places_view AS
WITH custom_places AS (
  SELECT 
    'place_' || p.id::text AS place_id,  -- Combined id with prefix 'place_'
    p.name,
    ST_Y(p.location::geometry) AS lat,
    ST_X(p.location::geometry) AS long,
    p.location,
    p.created_at,
    p.updated_at,
    p.user_id,
    c.category_id,
    c.name AS category_name,
    c.name_sv AS category_name_sv,
    pc.category_id AS parent_category_id,
    pc.name AS parent_category_name,
    pc.name_sv AS parent_category_name_sv,
    'custom' AS source,  -- Source indicator: 'custom' for internal places
    CASE WHEN pe.place_id IS NOT NULL THEN true ELSE false END AS has_entrances  -- Check if place has entrances
  FROM public.custom_places p
  LEFT JOIN place_categories c ON p.category_id = c.category_id
  LEFT JOIN place_categories pc ON c.parent_category_id = pc.category_id
  LEFT JOIN (
    SELECT DISTINCT place_id  -- Already in the combined format (place_123)
    FROM public.place_entrances
  ) pe ON 'place_' || p.id::text = pe.place_id  -- Match combined place_id in custom places
),
osm_places AS (
  SELECT 
    'osm_' || osm.osm_id::text AS place_id,  -- Combined id with prefix 'osm_'
    osm.name,
    ST_Y(osm.geom::geometry) AS lat,
    ST_X(osm.geom::geometry) AS long,
    osm.geom AS location,
    NULL::timestamp with time zone AS created_at,
    NULL::timestamp with time zone AS updated_at,
    NULL::uuid AS user_id,
    osm_c.category_id AS category_id,
    osm_c.name AS category_name,
    osm_c.name_sv AS category_name_sv,
    osm_pc.category_id AS parent_category_id,
    osm_pc.name AS parent_category_name,
    osm_pc.name_sv AS parent_category_name_sv,
    'osm' AS source,  -- Source indicator: 'osm' for OSM data
    CASE WHEN pe.place_id IS NOT NULL THEN true ELSE false END AS has_entrances  -- Check if OSM place has entrances
  FROM osm_import.sweden_osm_poi osm
  LEFT JOIN LATERAL (
    SELECT public.get_category_id_from_osm_tags(osm.tags::hstore) AS category_id
  ) AS osm_category ON true
  LEFT JOIN place_categories osm_c ON osm_category.category_id = osm_c.category_id
  LEFT JOIN place_categories osm_pc ON osm_c.parent_category_id = osm_pc.category_id
  LEFT JOIN (
    SELECT DISTINCT place_id
    FROM public.place_entrances
  ) pe ON 'osm_' || osm.osm_id::text = pe.place_id  -- Match combined osm_id in place_entrances
  LIMIT 1
)
-- Combine internal and OSM places
SELECT * FROM custom_places
UNION ALL
SELECT * FROM osm_places;


-- Create a unique index on the place_id column to allow concurrent refreshes
CREATE UNIQUE INDEX idx_detailed_places_view_place_id ON public.detailed_places_view (place_id);

-- end detailed_places_view


CREATE OR REPLACE VIEW public.detailed_entrances_view AS
WITH verified_entrances AS (
  SELECT 
    se.entrance_id::text AS entrance_id,  -- Cast to TEXT to unify with staging
    se.place_id,
    se.entrance_type_id,
    et.name AS entrance_type_name,
    et.name_sv AS entrance_type_name_sv,
    et.description AS entrance_type_description,
    et.description_sv AS entrance_type_description_sv,
    se.location,
    se.accessibility_info,
    json_agg(json_build_object(
      'photo_id', pei.photo_id,
      'photo_url', pei.photo_url,
      'description', pei.description
    )) AS photos,  -- Collect all photos for verified entrances
    'approved' AS status  -- Mark as approved
  FROM place_entrances se
  JOIN entrance_types et ON et.id = se.entrance_type_id
  LEFT JOIN place_entrance_photos pei ON pei.entrance_id = se.entrance_id  -- Join photos
  GROUP BY se.entrance_id, se.place_id, se.entrance_type_id, et.name, et.name_sv, et.description, et.description_sv, se.location, se.accessibility_info
),
pending_entrances AS (
  SELECT 
    NULL AS entrance_id,
    ecs.entity_id::text AS place_id,
    (ecs.change_data->>'entrance_type_id')::integer AS entrance_type_id,
    et.name AS entrance_type_name,
    et.name_sv AS entrance_type_name_sv,
    et.description AS entrance_type_description,
    et.description_sv AS entrance_type_description_sv,
    ST_SetSRID(ST_MakePoint(
      (ecs.change_data->'location'->>'long')::float,
      (ecs.change_data->'location'->>'lat')::float
    ), 4326) AS location,
    NULL::jsonb AS accessibility_info,
    json_build_array(json_build_object(
      'photo_id', NULL,
      'photo_url', ecs.change_data->>'photo_url',
      'description', NULL
    )) AS photos,
    ecs.status
  FROM entity_changes_staging ecs
  LEFT JOIN entrance_types et ON et.id = (ecs.change_data->>'entrance_type_id')::integer
  WHERE ecs.entity_type = 'entrance'
)
-- Combine verified and pending entrances
SELECT * FROM verified_entrances
UNION ALL
SELECT * FROM pending_entrances;


-- end detailed_entrances_view


CREATE OR REPLACE FUNCTION validate_place_combined_id()
RETURNS TRIGGER AS $$
BEGIN
  -- Check if the place_combined_id exists in the detailed_places_view
  IF NOT EXISTS (
    SELECT 1
    FROM public.detailed_places_view
    WHERE place_id = NEW.place_id  -- Check if the combined id exists
  ) THEN
    RAISE EXCEPTION 'Invalid place_id: % does not exist in detailed_places_view', NEW.place_id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_place_combined_id
BEFORE INSERT OR UPDATE ON public.place_entrances
FOR EACH ROW
EXECUTE FUNCTION validate_place_combined_id();


CREATE OR REPLACE FUNCTION public.refresh_detailed_places_view()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.detailed_places_view;
END;
$$ LANGUAGE plpgsql;


-- Grant necessary permissions
GRANT SELECT ON public.detailed_places_view TO PUBLIC;
CREATE INDEX idx_detailed_places_view_category_id ON public.detailed_places_view (category_id);



-- Triggers
--CREATE TRIGGER check_osm_id BEFORE INSERT OR UPDATE ON public.custom_places FOR EACH ROW EXECUTE FUNCTION check_valid_osm_id();

-- Permissions
-- Grant statements for tables and functions remain unchanged

-- Policies
CREATE POLICY "Enable read access for all users" ON "public"."custom_places" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."place_categories" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."place_entrances" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."place_entrance_photos" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."entrance_types" AS PERMISSIVE FOR SELECT TO public USING (true);

--CREATE POLICY "Enable insert for authenticated users only" ON "public"."entity_changes_staging" AS PERMISSIVE FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable insert for public users" ON "public"."entity_changes_staging" AS PERMISSIVE FOR INSERT TO public WITH CHECK (true);
CREATE POLICY "Enable read access for public users" ON "public"."entity_changes_staging" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable update for public users" ON "public"."entity_changes_staging" AS PERMISSIVE FOR UPDATE TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable delete for public users" ON "public"."entity_changes_staging" AS PERMISSIVE FOR DELETE TO public USING (true);

-- Enable Row Level Security
ALTER TABLE "public"."place_osm_tag_to_category" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."place_categories" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."place_entrances" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."place_entrance_photos" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entity_changes_staging" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entity_changes_audit " ENABLE ROW LEVEL SECURITY;

-- Storage
ALTER TABLE "storage"."buckets" ENABLE ROW LEVEL SECURITY;

-- Policy for SELECT operations: Allow all users to read objects
CREATE POLICY "Enable read access for all users" ON storage.objects
FOR SELECT USING (true);

-- Policy for INSERT operations: Allow authenticated users to upload objects
CREATE POLICY "Enable upload for authenticated users only" ON storage.objects
FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Policy for UPDATE operations: Allow authenticated users to update their own objects
CREATE POLICY "Enable update for users based on user_id" ON storage.objects
FOR UPDATE USING (auth.uid() = owner);

-- Policy for DELETE operations: Allow authenticated users to delete their own objects
CREATE POLICY "Enable delete for users based on user_id" ON storage.objects
FOR DELETE USING (auth.uid() = owner);

-- End of Storage

set check_function_bodies = off;

grant delete on table "public"."user_notifications" to "anon";

grant insert on table "public"."user_notifications" to "anon";

grant references on table "public"."user_notifications" to "anon";

grant select on table "public"."user_notifications" to "anon";

grant trigger on table "public"."user_notifications" to "anon";

grant truncate on table "public"."user_notifications" to "anon";

grant update on table "public"."user_notifications" to "anon";

grant delete on table "public"."user_notifications" to "authenticated";

grant insert on table "public"."user_notifications" to "authenticated";

grant references on table "public"."user_notifications" to "authenticated";

grant select on table "public"."user_notifications" to "authenticated";

grant trigger on table "public"."user_notifications" to "authenticated";

grant truncate on table "public"."user_notifications" to "authenticated";

grant update on table "public"."user_notifications" to "authenticated";

grant delete on table "public"."user_notifications" to "postgres";

grant insert on table "public"."user_notifications" to "postgres";

grant references on table "public"."user_notifications" to "postgres";

grant select on table "public"."user_notifications" to "postgres";

grant trigger on table "public"."user_notifications" to "postgres";

grant truncate on table "public"."user_notifications" to "postgres";

grant update on table "public"."user_notifications" to "postgres";

grant delete on table "public"."user_notifications" to "service_role";

grant insert on table "public"."user_notifications" to "service_role";

grant references on table "public"."user_notifications" to "service_role";

grant select on table "public"."user_notifications" to "service_role";

grant trigger on table "public"."user_notifications" to "service_role";

grant truncate on table "public"."user_notifications" to "service_role";

grant update on table "public"."user_notifications" to "service_role";

grant delete on table "public"."place_osm_tag_to_category" to "anon";

grant insert on table "public"."place_osm_tag_to_category" to "anon";

grant references on table "public"."place_osm_tag_to_category" to "anon";

grant select on table "public"."place_osm_tag_to_category" to "anon";

grant trigger on table "public"."place_osm_tag_to_category" to "anon";

grant truncate on table "public"."place_osm_tag_to_category" to "anon";

grant update on table "public"."place_osm_tag_to_category" to "anon";

grant delete on table "public"."place_osm_tag_to_category" to "authenticated";

grant insert on table "public"."place_osm_tag_to_category" to "authenticated";

grant references on table "public"."place_osm_tag_to_category" to "authenticated";

grant select on table "public"."place_osm_tag_to_category" to "authenticated";

grant trigger on table "public"."place_osm_tag_to_category" to "authenticated";

grant truncate on table "public"."place_osm_tag_to_category" to "authenticated";

grant update on table "public"."place_osm_tag_to_category" to "authenticated";

grant delete on table "public"."place_osm_tag_to_category" to "postgres";

grant insert on table "public"."place_osm_tag_to_category" to "postgres";

grant references on table "public"."place_osm_tag_to_category" to "postgres";

grant select on table "public"."place_osm_tag_to_category" to "postgres";

grant trigger on table "public"."place_osm_tag_to_category" to "postgres";

grant truncate on table "public"."place_osm_tag_to_category" to "postgres";

grant update on table "public"."place_osm_tag_to_category" to "postgres";

grant delete on table "public"."place_osm_tag_to_category" to "service_role";

grant insert on table "public"."place_osm_tag_to_category" to "service_role";

grant references on table "public"."place_osm_tag_to_category" to "service_role";

grant select on table "public"."place_osm_tag_to_category" to "service_role";

grant trigger on table "public"."place_osm_tag_to_category" to "service_role";

grant truncate on table "public"."place_osm_tag_to_category" to "service_role";

grant update on table "public"."place_osm_tag_to_category" to "service_role";

grant delete on table "public"."place_categories" to "anon";

grant insert on table "public"."place_categories" to "anon";

grant references on table "public"."place_categories" to "anon";

grant select on table "public"."place_categories" to "anon";

grant trigger on table "public"."place_categories" to "anon";

grant truncate on table "public"."place_categories" to "anon";

grant update on table "public"."place_categories" to "anon";

grant delete on table "public"."place_categories" to "authenticated";

grant insert on table "public"."place_categories" to "authenticated";

grant references on table "public"."place_categories" to "authenticated";

grant select on table "public"."place_categories" to "authenticated";

grant trigger on table "public"."place_categories" to "authenticated";

grant truncate on table "public"."place_categories" to "authenticated";

grant update on table "public"."place_categories" to "authenticated";

grant delete on table "public"."place_categories" to "postgres";

grant insert on table "public"."place_categories" to "postgres";

grant references on table "public"."place_categories" to "postgres";

grant select on table "public"."place_categories" to "postgres";

grant trigger on table "public"."place_categories" to "postgres";

grant truncate on table "public"."place_categories" to "postgres";

grant update on table "public"."place_categories" to "postgres";

grant delete on table "public"."place_categories" to "service_role";

grant insert on table "public"."place_categories" to "service_role";

grant references on table "public"."place_categories" to "service_role";

grant select on table "public"."place_categories" to "service_role";

grant trigger on table "public"."place_categories" to "service_role";

grant truncate on table "public"."place_categories" to "service_role";

grant update on table "public"."place_categories" to "service_role";

grant delete on table "public"."place_entrances" to "anon";

grant insert on table "public"."place_entrances" to "anon";

grant references on table "public"."place_entrances" to "anon";

grant select on table "public"."place_entrances" to "anon";

grant trigger on table "public"."place_entrances" to "anon";

grant truncate on table "public"."place_entrances" to "anon";

grant update on table "public"."place_entrances" to "anon";

grant delete on table "public"."place_entrances" to "authenticated";

grant insert on table "public"."place_entrances" to "authenticated";

grant references on table "public"."place_entrances" to "authenticated";

grant select on table "public"."place_entrances" to "authenticated";

grant trigger on table "public"."place_entrances" to "authenticated";

grant truncate on table "public"."place_entrances" to "authenticated";

grant update on table "public"."place_entrances" to "authenticated";

grant delete on table "public"."place_entrances" to "postgres";

grant insert on table "public"."place_entrances" to "postgres";

grant references on table "public"."place_entrances" to "postgres";

grant select on table "public"."place_entrances" to "postgres";

grant trigger on table "public"."place_entrances" to "postgres";

grant truncate on table "public"."place_entrances" to "postgres";

grant update on table "public"."place_entrances" to "postgres";

grant delete on table "public"."place_entrances" to "service_role";

grant insert on table "public"."place_entrances" to "service_role";

grant references on table "public"."place_entrances" to "service_role";

grant select on table "public"."place_entrances" to "service_role";

grant trigger on table "public"."place_entrances" to "service_role";

grant truncate on table "public"."place_entrances" to "service_role";

grant update on table "public"."place_entrances" to "service_role";

grant delete on table "public"."place_entrance_photos" to "anon";

grant insert on table "public"."place_entrance_photos" to "anon";

grant references on table "public"."place_entrance_photos" to "anon";

grant select on table "public"."place_entrance_photos" to "anon";

grant trigger on table "public"."place_entrance_photos" to "anon";

grant truncate on table "public"."place_entrance_photos" to "anon";

grant update on table "public"."place_entrance_photos" to "anon";

grant delete on table "public"."place_entrance_photos" to "authenticated";

grant insert on table "public"."place_entrance_photos" to "authenticated";

grant references on table "public"."place_entrance_photos" to "authenticated";

grant select on table "public"."place_entrance_photos" to "authenticated";

grant trigger on table "public"."place_entrance_photos" to "authenticated";

grant truncate on table "public"."place_entrance_photos" to "authenticated";

grant update on table "public"."place_entrance_photos" to "authenticated";

grant delete on table "public"."place_entrance_photos" to "postgres";

grant insert on table "public"."place_entrance_photos" to "postgres";

grant references on table "public"."place_entrance_photos" to "postgres";

grant select on table "public"."place_entrance_photos" to "postgres";

grant trigger on table "public"."place_entrance_photos" to "postgres";

grant truncate on table "public"."place_entrance_photos" to "postgres";

grant update on table "public"."place_entrance_photos" to "postgres";

grant delete on table "public"."place_entrance_photos" to "service_role";

grant insert on table "public"."place_entrance_photos" to "service_role";

grant references on table "public"."place_entrance_photos" to "service_role";

grant select on table "public"."place_entrance_photos" to "service_role";

grant trigger on table "public"."place_entrance_photos" to "service_role";

grant truncate on table "public"."place_entrance_photos" to "service_role";

grant update on table "public"."place_entrance_photos" to "service_role";

grant delete on table "public"."custom_places" to "anon";

grant insert on table "public"."custom_places" to "anon";

grant references on table "public"."custom_places" to "anon";

grant select on table "public"."custom_places" to "anon";

grant trigger on table "public"."custom_places" to "anon";

grant truncate on table "public"."custom_places" to "anon";

grant update on table "public"."custom_places" to "anon";

grant delete on table "public"."custom_places" to "authenticated";

grant insert on table "public"."custom_places" to "authenticated";

grant references on table "public"."custom_places" to "authenticated";

grant select on table "public"."custom_places" to "authenticated";

grant trigger on table "public"."custom_places" to "authenticated";

grant truncate on table "public"."custom_places" to "authenticated";

grant update on table "public"."custom_places" to "authenticated";

grant delete on table "public"."custom_places" to "postgres";

grant insert on table "public"."custom_places" to "postgres";

grant references on table "public"."custom_places" to "postgres";

grant select on table "public"."custom_places" to "postgres";

grant trigger on table "public"."custom_places" to "postgres";

grant truncate on table "public"."custom_places" to "postgres";

grant update on table "public"."custom_places" to "postgres";

grant delete on table "public"."custom_places" to "service_role";

grant insert on table "public"."custom_places" to "service_role";

grant references on table "public"."custom_places" to "service_role";

grant select on table "public"."custom_places" to "service_role";

grant trigger on table "public"."custom_places" to "service_role";

grant truncate on table "public"."custom_places" to "service_role";

grant update on table "public"."custom_places" to "service_role";

grant delete on table "public"."users" to "anon";

grant insert on table "public"."users" to "anon";

grant references on table "public"."users" to "anon";

grant select on table "public"."users" to "anon";

grant trigger on table "public"."users" to "anon";

grant truncate on table "public"."users" to "anon";

grant update on table "public"."users" to "anon";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "postgres";

grant insert on table "public"."users" to "postgres";

grant references on table "public"."users" to "postgres";

grant select on table "public"."users" to "postgres";

grant trigger on table "public"."users" to "postgres";

grant truncate on table "public"."users" to "postgres";

grant update on table "public"."users" to "postgres";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";
