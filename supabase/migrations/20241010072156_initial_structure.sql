create extension if not exists "hstore" with schema "extensions";

create extension if not exists "moddatetime" with schema "extensions";

create extension if not exists "postgis" with schema "extensions";

create extension if not exists "postgres_fdw" with schema "extensions";

create server osm_remote_server foreign data wrapper postgres_fdw options (host '135.181.108.171', dbname 'postgres', port '5433');

create user mapping for current_user server osm_remote_server options (user 'postgres', password 'p4ik5IdbSwQBMaUNBUgashGjZUxBhkN9Autx9R9Yj9VeXNgOIMYzhIuapPKn8ti1');

create schema if not exists osm_import;

import foreign schema public
from server osm_remote_server
into osm_import;

create type "public"."contribution_action" as enum ('ADD', 'UPDATE', 'REPORT', 'PHOTO_UPLOAD');

create type "public"."contribution_status" as enum ('PENDING', 'APPROVED', 'REJECTED');

create sequence "public"."user_notifications_notification_id_seq";

create sequence "public"."place_entrances_id_seq";

create sequence "public"."places_place_id_seq";

create table "public"."user_notifications" (
    "notification_id" integer not null default nextval('user_notifications_notification_id_seq'::regclass),
    "user_id" uuid,
    "message" text not null,
    "is_read" boolean default false,
    "created_at" timestamp with time zone default now()
);


create table "public"."place_osm_tag_to_category" (
    "id" bigint generated by default as identity not null,
    "tag_key" text not null,
    "tag_value" text not null,
    "category_id" bigint,
    "priority" integer not null default 0,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone default (now() AT TIME ZONE 'utc'::text)
);


alter table "public"."place_osm_tag_to_category" enable row level security;

create table "public"."place_categories" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "name_sv" text not null,
    "parent_category_id" bigint,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone default (now() AT TIME ZONE 'utc'::text)
);


alter table "public"."place_categories" enable row level security;

create table "public"."place_entrances" (
    "id" integer not null default nextval('place_entrances_id_seq'::regclass),
    "place_id" integer not null,
    "type_id" integer not null,
    "location" geometry,
    "accessibility_info" jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."place_entrances" enable row level security;

create table "public"."entrance_types" (
    "id" integer not null,
    "name" text not null,
    "name_sv" text not null,
    "description" text,
    "description_sv" text,
    "is_active" boolean not null default true,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text)
);

alter table "public"."entrance_types" enable row level security;

create table "public"."place_entrance_images" (
    "id" bigint generated by default as identity not null,
    "place_id" integer,
    "user_id" uuid,
    "image_url" character varying,
    "description" text,
    "entrance_id" integer,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone default (now() AT TIME ZONE 'utc'::text)
);


alter table "public"."place_entrance_images" enable row level security;

create table "public"."places" (
    "id" integer not null default nextval('places_place_id_seq'::regclass),
    "osm_id" bigint,
    "name" character varying(255),
    "location" geometry(Point,4326),
    "category_id" bigint,
    "osm_tags" jsonb,
    "user_id" uuid,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text)
);


create table "public"."user_contributions" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "place_id" integer not null,
    "action_type" contribution_action not null,
    "status" contribution_status default 'PENDING'::contribution_status,
    "details" jsonb,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text)
);


alter table "public"."user_contributions" enable row level security;

create table "public"."users" (
    "id" uuid not null,
    "email" text,
    "first_name" text,
    "last_name" text
);

alter sequence "public"."user_notifications_notification_id_seq" owned by "public"."user_notifications"."notification_id";

alter sequence "public"."place_entrances_id_seq" owned by "public"."place_entrances"."id";

alter sequence "public"."places_place_id_seq" owned by "public"."places"."id";

CREATE INDEX idx_place_entrance_images_place_id ON public.place_entrance_images USING btree (place_id);

CREATE INDEX idx_place_entrance_images_user_id ON public.place_entrance_images USING btree (user_id);

CREATE INDEX idx_places_category_id ON public.places USING btree (category_id);

CREATE INDEX idx_places_location ON public.places USING gist (location);

CREATE INDEX idx_places_osm_id ON public.places USING btree (osm_id);

CREATE INDEX idx_user_contributions_place_id ON public.user_contributions USING btree (place_id);

CREATE INDEX idx_user_contributions_user_id ON public.user_contributions USING btree (user_id);

CREATE UNIQUE INDEX user_notifications_pkey ON public.user_notifications USING btree (notification_id);

CREATE UNIQUE INDEX place_categories_pkey ON public.place_categories USING btree (id);

CREATE UNIQUE INDEX place_entrances_pkey ON public.place_entrances USING btree (id);

CREATE UNIQUE INDEX place_entrance_images_pkey ON public.place_entrance_images USING btree (id);

CREATE UNIQUE INDEX places_osm_id_key ON public.places USING btree (osm_id);

CREATE UNIQUE INDEX places_pkey ON public.places USING btree (id);

CREATE UNIQUE INDEX tag_category_mapping_pkey ON public.place_osm_tag_to_category USING btree (id);

CREATE UNIQUE INDEX unique_name ON public.place_categories USING btree (name);

CREATE UNIQUE INDEX user_contributions_place_id_key ON public.user_contributions USING btree (place_id);

CREATE UNIQUE INDEX users_contributions_pkey ON public.user_contributions USING btree (id);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

alter table "public"."user_notifications" add constraint "user_notifications_pkey" PRIMARY KEY using index "user_notifications_pkey";

alter table "public"."place_osm_tag_to_category" add constraint "tag_category_mapping_pkey" PRIMARY KEY using index "tag_category_mapping_pkey";

alter table "public"."place_categories" add constraint "place_categories_pkey" PRIMARY KEY using index "place_categories_pkey";

alter table "public"."place_entrances" add constraint "place_entrances_pkey" PRIMARY KEY using index "place_entrances_pkey";

alter table "public"."place_entrance_images" add constraint "place_entrance_images_pkey" PRIMARY KEY using index "place_entrance_images_pkey";

alter table "public"."places" add constraint "places_pkey" PRIMARY KEY using index "places_pkey";

alter table "public"."user_contributions" add constraint "users_contributions_pkey" PRIMARY KEY using index "users_contributions_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."place_osm_tag_to_category" add constraint "tag_category_mapping_place_category_id_fkey" FOREIGN KEY (category_id) REFERENCES place_categories(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."place_osm_tag_to_category" validate constraint "tag_category_mapping_place_category_id_fkey";

alter table "public"."place_categories" add constraint "place_categories_parent_category_fkey" FOREIGN KEY (parent_category_id) REFERENCES place_categories(id) not valid;

alter table "public"."place_categories" validate constraint "place_categories_parent_category_fkey";

alter table "public"."place_categories" add constraint "unique_name" UNIQUE using index "unique_name";

alter table "public"."place_entrances" add constraint "place_entrances_place_id_fkey" FOREIGN KEY (place_id) REFERENCES places(id) ON DELETE CASCADE not valid;

alter table "public"."place_entrances" validate constraint "place_entrances_place_id_fkey";

alter table "public"."place_entrance_images" add constraint "place_entrance_images_entrance_id_fkey" FOREIGN KEY (entrance_id) REFERENCES place_entrances(id) not valid;

alter table "public"."place_entrance_images" validate constraint "place_entrance_images_entrance_id_fkey";

alter table "public"."place_entrance_images" add constraint "place_entrance_images_place_id_fkey" FOREIGN KEY (place_id) REFERENCES places(id) ON DELETE CASCADE not valid;

alter table "public"."place_entrance_images" validate constraint "place_entrance_images_place_id_fkey";

alter table "public"."places" add constraint "places_category_id_fkey" FOREIGN KEY (category_id) REFERENCES place_categories(id) not valid;

alter table "public"."places" validate constraint "places_category_id_fkey";

alter table "public"."places" add constraint "places_osm_id_key" UNIQUE using index "places_osm_id_key";

alter table "public"."places" add constraint "places_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL not valid;

alter table "public"."places" validate constraint "places_user_id_fkey";

alter table "public"."user_contributions" add constraint "user_contributions_place_id_key" UNIQUE using index "user_contributions_place_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_place_from_osm(osm_id bigint)
 RETURNS places
 LANGUAGE plpgsql
AS $function$DECLARE
    osm_name TEXT;
    osm_tags HSTORE;
    osm_location GEOMETRY;
    place_category_id INTEGER;
    new_place places%ROWTYPE;
BEGIN
    -- Fetch OSM information from sweden_osm_poi
    SELECT n.tags->'name',
           n.tags,
           n.geom
    INTO osm_name, osm_tags, osm_location
    FROM osm_import.sweden_osm_poi n
    WHERE n.osm_id = $1;

    -- If no OSM record is found, raise an error
    IF osm_name IS NULL THEN
        RAISE EXCEPTION 'OSM ID % does not exist or has no name', $1;
    END IF;

    -- Determine the category using the existing function
    SELECT get_category_id_from_osm_tags(osm_tags)
    INTO place_category_id;

    -- Insert a new place into the places table and get the entire inserted row
    INSERT INTO places (
        osm_id,
        name,
        location,
        osm_tags,
        category_id,
        created_at,
        updated_at
    )
    VALUES (
        $1,
        osm_name,
        osm_location,
        hstore_to_jsonb(osm_tags),
        place_category_id,
        NOW(),
        NOW()
    )
    RETURNING * INTO new_place;

    -- Raise a notice for successful creation
    RAISE NOTICE 'Place created successfully for OSM ID %', $1;

    -- Return the entire inserted row
    RETURN new_place;

END;$function$
;

create or replace view "public"."detailed_entrances_view" as  SELECT 
    se.id AS entrance_id,
    se.place_id,
    s.osm_id,
    s.name AS place_name,
    se.type_id AS entrance_type_id,
    et.name AS entrance_type_name,
    et.name_sv AS entrance_type_name_sv,
    et.description AS entrance_type_description,
    et.description_sv AS entrance_type_description_sv,
    st_y(se.location) AS lat,
    st_x(se.location) AS long,
    se.accessibility_info,
    se.created_at AS entrance_created_at,
    se.updated_at AS entrance_updated_at,
    et.created_at AS entrance_type_created_at
   FROM place_entrances se
   JOIN places s ON s.id = se.place_id
   JOIN entrance_types et ON et.id = se.type_id;


CREATE OR REPLACE FUNCTION public.email_exists(email character varying)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    val VARCHAR;
BEGIN
    SELECT u.email INTO val FROM users u
    WHERE u.email = LOWER($1);  -- Use function argument explicitly to avoid ambiguity

    IF FOUND THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_category_id_from_osm_tags(tags hstore)
RETURNS integer
LANGUAGE plpgsql
STABLE
AS $function$
DECLARE
    cat_id INTEGER;
    other_category_id INTEGER;
    current_key TEXT;
    current_value TEXT;
BEGIN
    -- First, try to find an exact match
    SELECT category_id INTO cat_id
    FROM place_osm_tag_to_category
    WHERE (tag_key, tag_value) IN (SELECT key, value FROM each(tags))
    ORDER BY priority DESC
    LIMIT 1;

    -- If no exact match, try wildcard matches
    IF cat_id IS NULL THEN
        FOR current_key, current_value IN SELECT key, value FROM each(tags)
        LOOP
            -- Try to match the specific key with a wildcard value
            SELECT category_id INTO cat_id
            FROM place_osm_tag_to_category
            WHERE tag_key = current_key AND tag_value = '*'
            ORDER BY priority DESC
            LIMIT 1;

            EXIT WHEN cat_id IS NOT NULL;
        END LOOP;
    END IF;

    -- If a category is found, log it and return
    IF cat_id IS NOT NULL THEN
        RAISE NOTICE 'Category found: %', cat_id;
        RETURN cat_id;
    END IF;

    -- If no category found, set it to 'Other'
    SELECT id INTO other_category_id 
    FROM place_categories 
    WHERE name = 'Other'
    LIMIT 1;
    
    IF other_category_id IS NULL THEN
        RAISE EXCEPTION 'Other category not found in place_categories';
    END IF;

    RAISE NOTICE 'No specific category found. Using Other category: %', other_category_id;
    RETURN other_category_id;

EXCEPTION
    WHEN too_many_rows THEN
        RAISE EXCEPTION 'Multiple categories found for the given tags. Please refine the mapping.';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error in get_category_id_from_osm_tags: %', SQLERRM;
END;
$function$;


CREATE OR REPLACE FUNCTION public.get_places_in_bounding_box(min_lat double precision, min_long double precision, max_lat double precision, max_long double precision)
 RETURNS TABLE(place_id integer, osm_id bigint, name text, lat double precision, long double precision, created_at timestamp with time zone, updated_at timestamp with time zone, osm_tags jsonb, user_id uuid, user_created_at timestamp with time zone, user_updated_at timestamp with time zone, category_name text, parent_category_name text)
 LANGUAGE plpgsql
AS $function$BEGIN
    PERFORM set_config('search_path', 'public, extensions', false);

    RETURN QUERY
    SELECT 
        v.place_id,
        v.osm_id,
        v.name::TEXT,
        v.lat,
        v.long,
        v.created_at,
        v.updated_at,
        v.osm_tags,
        v.user_id,
        v.user_created_at,
        v.user_updated_at,
        v.category_name::TEXT,
        v.parent_category_name::TEXT,
    FROM detailed_places_view v
    WHERE extensions.ST_SetSRID(
            extensions.ST_MakeBox2D(
                extensions.ST_Point(min_long, min_lat), 
                extensions.ST_Point(max_long, max_lat)
            ), 4326
          )::geometry && v.location::geometry;  -- Ensure both are explicitly cast to geography
END;$function$
;


CREATE OR REPLACE FUNCTION public.get_nearest_places(
    user_lat double precision,
    user_long double precision,
    limit_count integer DEFAULT 10,
    max_distance_meters double precision DEFAULT 10000 -- Default 10km
)
RETURNS TABLE(
    place_id integer,
    osm_id bigint,
    name text,
    lat double precision,
    long double precision,
    distance_meters double precision,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    osm_tags jsonb,
    user_id uuid,
    category_name text,
    parent_category_name text
)
LANGUAGE plpgsql
AS $function$
DECLARE
    user_location geometry;
BEGIN
    PERFORM set_config('search_path', 'public, extensions', false);

    -- Create a point geometry from the input latitude and longitude
    user_location := ST_SetSRID(ST_MakePoint(user_long, user_lat), 4326);

    RETURN QUERY
    SELECT 
        v.place_id,
        v.osm_id,
        v.name::TEXT,
        ST_Y(v.location::geometry) AS lat,
        ST_X(v.location::geometry) AS long,
        ST_Distance(v.location::geography, user_location::geography) AS distance_meters,
        v.created_at,
        v.updated_at,
        v.osm_tags,
        v.user_id,
        v.category_name::TEXT,
        v.parent_category_name::TEXT
    FROM detailed_places_view v
    WHERE ST_DWithin(
        v.location::geography,
        user_location::geography,
        max_distance_meters
    )
    ORDER BY v.location::geography <-> user_location::geography
    LIMIT limit_count;
END;
$function$;


CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.users (id, email)
  values (new.id, new.email);
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_osm_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
  -- Only validate if osm_id is NOT NULL
  IF NEW.osm_id IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1 FROM osm_import.sweden_osm_poi
      WHERE osm_id = NEW.osm_id
    ) THEN
      RAISE EXCEPTION 'Invalid osm_id: %', NEW.osm_id;
    END IF;
  END IF;
  RETURN NEW;
END;$function$
;


grant delete on table "public"."user_notifications" to "anon";

grant insert on table "public"."user_notifications" to "anon";

grant references on table "public"."user_notifications" to "anon";

grant select on table "public"."user_notifications" to "anon";

grant trigger on table "public"."user_notifications" to "anon";

grant truncate on table "public"."user_notifications" to "anon";

grant update on table "public"."user_notifications" to "anon";

grant delete on table "public"."user_notifications" to "authenticated";

grant insert on table "public"."user_notifications" to "authenticated";

grant references on table "public"."user_notifications" to "authenticated";

grant select on table "public"."user_notifications" to "authenticated";

grant trigger on table "public"."user_notifications" to "authenticated";

grant truncate on table "public"."user_notifications" to "authenticated";

grant update on table "public"."user_notifications" to "authenticated";

grant delete on table "public"."user_notifications" to "postgres";

grant insert on table "public"."user_notifications" to "postgres";

grant references on table "public"."user_notifications" to "postgres";

grant select on table "public"."user_notifications" to "postgres";

grant trigger on table "public"."user_notifications" to "postgres";

grant truncate on table "public"."user_notifications" to "postgres";

grant update on table "public"."user_notifications" to "postgres";

grant delete on table "public"."user_notifications" to "service_role";

grant insert on table "public"."user_notifications" to "service_role";

grant references on table "public"."user_notifications" to "service_role";

grant select on table "public"."user_notifications" to "service_role";

grant trigger on table "public"."user_notifications" to "service_role";

grant truncate on table "public"."user_notifications" to "service_role";

grant update on table "public"."user_notifications" to "service_role";

grant delete on table "public"."place_osm_tag_to_category" to "anon";

grant insert on table "public"."place_osm_tag_to_category" to "anon";

grant references on table "public"."place_osm_tag_to_category" to "anon";

grant select on table "public"."place_osm_tag_to_category" to "anon";

grant trigger on table "public"."place_osm_tag_to_category" to "anon";

grant truncate on table "public"."place_osm_tag_to_category" to "anon";

grant update on table "public"."place_osm_tag_to_category" to "anon";

grant delete on table "public"."place_osm_tag_to_category" to "authenticated";

grant insert on table "public"."place_osm_tag_to_category" to "authenticated";

grant references on table "public"."place_osm_tag_to_category" to "authenticated";

grant select on table "public"."place_osm_tag_to_category" to "authenticated";

grant trigger on table "public"."place_osm_tag_to_category" to "authenticated";

grant truncate on table "public"."place_osm_tag_to_category" to "authenticated";

grant update on table "public"."place_osm_tag_to_category" to "authenticated";

grant delete on table "public"."place_osm_tag_to_category" to "postgres";

grant insert on table "public"."place_osm_tag_to_category" to "postgres";

grant references on table "public"."place_osm_tag_to_category" to "postgres";

grant select on table "public"."place_osm_tag_to_category" to "postgres";

grant trigger on table "public"."place_osm_tag_to_category" to "postgres";

grant truncate on table "public"."place_osm_tag_to_category" to "postgres";

grant update on table "public"."place_osm_tag_to_category" to "postgres";

grant delete on table "public"."place_osm_tag_to_category" to "service_role";

grant insert on table "public"."place_osm_tag_to_category" to "service_role";

grant references on table "public"."place_osm_tag_to_category" to "service_role";

grant select on table "public"."place_osm_tag_to_category" to "service_role";

grant trigger on table "public"."place_osm_tag_to_category" to "service_role";

grant truncate on table "public"."place_osm_tag_to_category" to "service_role";

grant update on table "public"."place_osm_tag_to_category" to "service_role";

grant delete on table "public"."place_categories" to "anon";

grant insert on table "public"."place_categories" to "anon";

grant references on table "public"."place_categories" to "anon";

grant select on table "public"."place_categories" to "anon";

grant trigger on table "public"."place_categories" to "anon";

grant truncate on table "public"."place_categories" to "anon";

grant update on table "public"."place_categories" to "anon";

grant delete on table "public"."place_categories" to "authenticated";

grant insert on table "public"."place_categories" to "authenticated";

grant references on table "public"."place_categories" to "authenticated";

grant select on table "public"."place_categories" to "authenticated";

grant trigger on table "public"."place_categories" to "authenticated";

grant truncate on table "public"."place_categories" to "authenticated";

grant update on table "public"."place_categories" to "authenticated";

grant delete on table "public"."place_categories" to "postgres";

grant insert on table "public"."place_categories" to "postgres";

grant references on table "public"."place_categories" to "postgres";

grant select on table "public"."place_categories" to "postgres";

grant trigger on table "public"."place_categories" to "postgres";

grant truncate on table "public"."place_categories" to "postgres";

grant update on table "public"."place_categories" to "postgres";

grant delete on table "public"."place_categories" to "service_role";

grant insert on table "public"."place_categories" to "service_role";

grant references on table "public"."place_categories" to "service_role";

grant select on table "public"."place_categories" to "service_role";

grant trigger on table "public"."place_categories" to "service_role";

grant truncate on table "public"."place_categories" to "service_role";

grant update on table "public"."place_categories" to "service_role";

grant delete on table "public"."place_entrances" to "anon";

grant insert on table "public"."place_entrances" to "anon";

grant references on table "public"."place_entrances" to "anon";

grant select on table "public"."place_entrances" to "anon";

grant trigger on table "public"."place_entrances" to "anon";

grant truncate on table "public"."place_entrances" to "anon";

grant update on table "public"."place_entrances" to "anon";

grant delete on table "public"."place_entrances" to "authenticated";

grant insert on table "public"."place_entrances" to "authenticated";

grant references on table "public"."place_entrances" to "authenticated";

grant select on table "public"."place_entrances" to "authenticated";

grant trigger on table "public"."place_entrances" to "authenticated";

grant truncate on table "public"."place_entrances" to "authenticated";

grant update on table "public"."place_entrances" to "authenticated";

grant delete on table "public"."place_entrances" to "postgres";

grant insert on table "public"."place_entrances" to "postgres";

grant references on table "public"."place_entrances" to "postgres";

grant select on table "public"."place_entrances" to "postgres";

grant trigger on table "public"."place_entrances" to "postgres";

grant truncate on table "public"."place_entrances" to "postgres";

grant update on table "public"."place_entrances" to "postgres";

grant delete on table "public"."place_entrances" to "service_role";

grant insert on table "public"."place_entrances" to "service_role";

grant references on table "public"."place_entrances" to "service_role";

grant select on table "public"."place_entrances" to "service_role";

grant trigger on table "public"."place_entrances" to "service_role";

grant truncate on table "public"."place_entrances" to "service_role";

grant update on table "public"."place_entrances" to "service_role";

grant delete on table "public"."place_entrance_images" to "anon";

grant insert on table "public"."place_entrance_images" to "anon";

grant references on table "public"."place_entrance_images" to "anon";

grant select on table "public"."place_entrance_images" to "anon";

grant trigger on table "public"."place_entrance_images" to "anon";

grant truncate on table "public"."place_entrance_images" to "anon";

grant update on table "public"."place_entrance_images" to "anon";

grant delete on table "public"."place_entrance_images" to "authenticated";

grant insert on table "public"."place_entrance_images" to "authenticated";

grant references on table "public"."place_entrance_images" to "authenticated";

grant select on table "public"."place_entrance_images" to "authenticated";

grant trigger on table "public"."place_entrance_images" to "authenticated";

grant truncate on table "public"."place_entrance_images" to "authenticated";

grant update on table "public"."place_entrance_images" to "authenticated";

grant delete on table "public"."place_entrance_images" to "postgres";

grant insert on table "public"."place_entrance_images" to "postgres";

grant references on table "public"."place_entrance_images" to "postgres";

grant select on table "public"."place_entrance_images" to "postgres";

grant trigger on table "public"."place_entrance_images" to "postgres";

grant truncate on table "public"."place_entrance_images" to "postgres";

grant update on table "public"."place_entrance_images" to "postgres";

grant delete on table "public"."place_entrance_images" to "service_role";

grant insert on table "public"."place_entrance_images" to "service_role";

grant references on table "public"."place_entrance_images" to "service_role";

grant select on table "public"."place_entrance_images" to "service_role";

grant trigger on table "public"."place_entrance_images" to "service_role";

grant truncate on table "public"."place_entrance_images" to "service_role";

grant update on table "public"."place_entrance_images" to "service_role";

grant delete on table "public"."places" to "anon";

grant insert on table "public"."places" to "anon";

grant references on table "public"."places" to "anon";

grant select on table "public"."places" to "anon";

grant trigger on table "public"."places" to "anon";

grant truncate on table "public"."places" to "anon";

grant update on table "public"."places" to "anon";

grant delete on table "public"."places" to "authenticated";

grant insert on table "public"."places" to "authenticated";

grant references on table "public"."places" to "authenticated";

grant select on table "public"."places" to "authenticated";

grant trigger on table "public"."places" to "authenticated";

grant truncate on table "public"."places" to "authenticated";

grant update on table "public"."places" to "authenticated";

grant delete on table "public"."places" to "postgres";

grant insert on table "public"."places" to "postgres";

grant references on table "public"."places" to "postgres";

grant select on table "public"."places" to "postgres";

grant trigger on table "public"."places" to "postgres";

grant truncate on table "public"."places" to "postgres";

grant update on table "public"."places" to "postgres";

grant delete on table "public"."places" to "service_role";

grant insert on table "public"."places" to "service_role";

grant references on table "public"."places" to "service_role";

grant select on table "public"."places" to "service_role";

grant trigger on table "public"."places" to "service_role";

grant truncate on table "public"."places" to "service_role";

grant update on table "public"."places" to "service_role";

grant delete on table "public"."user_contributions" to "anon";

grant insert on table "public"."user_contributions" to "anon";

grant references on table "public"."user_contributions" to "anon";

grant select on table "public"."user_contributions" to "anon";

grant trigger on table "public"."user_contributions" to "anon";

grant truncate on table "public"."user_contributions" to "anon";

grant update on table "public"."user_contributions" to "anon";

grant delete on table "public"."user_contributions" to "authenticated";

grant insert on table "public"."user_contributions" to "authenticated";

grant references on table "public"."user_contributions" to "authenticated";

grant select on table "public"."user_contributions" to "authenticated";

grant trigger on table "public"."user_contributions" to "authenticated";

grant truncate on table "public"."user_contributions" to "authenticated";

grant update on table "public"."user_contributions" to "authenticated";

grant delete on table "public"."user_contributions" to "postgres";

grant insert on table "public"."user_contributions" to "postgres";

grant references on table "public"."user_contributions" to "postgres";

grant select on table "public"."user_contributions" to "postgres";

grant trigger on table "public"."user_contributions" to "postgres";

grant truncate on table "public"."user_contributions" to "postgres";

grant update on table "public"."user_contributions" to "postgres";

grant delete on table "public"."user_contributions" to "service_role";

grant insert on table "public"."user_contributions" to "service_role";

grant references on table "public"."user_contributions" to "service_role";

grant select on table "public"."user_contributions" to "service_role";

grant trigger on table "public"."user_contributions" to "service_role";

grant truncate on table "public"."user_contributions" to "service_role";

grant update on table "public"."user_contributions" to "service_role";

grant delete on table "public"."users" to "anon";

grant insert on table "public"."users" to "anon";

grant references on table "public"."users" to "anon";

grant select on table "public"."users" to "anon";

grant trigger on table "public"."users" to "anon";

grant truncate on table "public"."users" to "anon";

grant update on table "public"."users" to "anon";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "postgres";

grant insert on table "public"."users" to "postgres";

grant references on table "public"."users" to "postgres";

grant select on table "public"."users" to "postgres";

grant trigger on table "public"."users" to "postgres";

grant truncate on table "public"."users" to "postgres";

grant update on table "public"."users" to "postgres";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";



create policy "Enable read access for all users"
on "public"."places"
as permissive
for select
to public
using (true);

create policy "Enable read access for all users"
on "public"."place_categories"
as permissive
for select
to public
using (true);


create policy "Enable read access for all users"
on "public"."place_entrances"
as permissive
for select
to public
using (true);

create policy "Enable read access for all users"
on "public"."place_entrance_images"
as permissive
for select
to public
using (true);

create policy "Enable read access for all users"
on "public"."entrance_types"
as permissive
for select
to public
using (true);

create policy "Enable read access for all users"
on "public"."user_contributions"
as permissive
for select
to public
using (true);


CREATE TRIGGER check_osm_id BEFORE INSERT OR UPDATE ON public.places FOR EACH ROW EXECUTE FUNCTION validate_osm_id();


-- Create a function to build the materialized view
CREATE OR REPLACE FUNCTION create_detailed_places_view()
RETURNS void AS $$
BEGIN
  -- Drop the materialized view if it exists
  DROP MATERIALIZED VIEW IF EXISTS public.detailed_places_view;

  -- Create the materialized view
  EXECUTE '
  CREATE MATERIALIZED VIEW public.detailed_places_view AS
  WITH custom_places AS (
    SELECT 
        p.id AS place_id,
        p.osm_id,
        p.name,
        p.osm_tags,
        ST_Y(p.location::geometry) AS lat,
        ST_X(p.location::geometry) AS long,
        p.location,
        p.created_at,
        p.updated_at,
        p.user_id,
        c.id AS category_id,
        c.name AS category_name,
        c.name_sv AS category_name_sv,
        pc.id AS parent_category_id,
        pc.name AS parent_category_name,
        pc.name_sv AS parent_category_name_sv,
        NULL AS source,
        CASE WHEN pe.place_id IS NOT NULL THEN true ELSE false END AS has_entrances
    FROM public.places p
    LEFT JOIN place_categories c ON p.category_id = c.id
    LEFT JOIN place_categories pc ON c.parent_category_id = pc.id
    LEFT JOIN (
        SELECT DISTINCT place_id
        FROM public.place_entrances
    ) pe ON p.id = pe.place_id
  ),
  osm_places AS (
    SELECT 
        NULL::integer AS id,
        osm.osm_id,
        osm.name,
        osm.tags::jsonb AS osm_tags,
        ST_Y(osm.geom::geometry) AS lat,
        ST_X(osm.geom::geometry) AS long,
        osm.geom AS location,
        NULL::timestamp with time zone AS created_at,
        NULL::timestamp with time zone AS updated_at,
        NULL::uuid AS user_id,
        osm_c.id AS category_id,
        osm_c.name AS category_name,
        osm_c.name_sv AS category_name_sv,
        osm_pc.id AS parent_category_id,
        osm_pc.name AS parent_category_name,
        osm_pc.name_sv AS parent_category_name_sv,
        ''osm'' AS source,
        false AS has_entrances
    FROM osm_import.sweden_osm_poi osm
    LEFT JOIN LATERAL (
        SELECT public.get_category_id_from_osm_tags(osm.tags::hstore) AS category_id
    ) AS osm_category ON true
    LEFT JOIN place_categories osm_c ON osm_category.category_id = osm_c.id
    LEFT JOIN place_categories osm_pc ON osm_c.parent_category_id = osm_pc.id
    WHERE osm.name IS NOT NULL
      AND osm.osm_id NOT IN (SELECT p2.osm_id FROM public.places p2 WHERE p2.osm_id IS NOT NULL)
    LIMIT 100
  )
  SELECT * FROM custom_places
  UNION ALL
  SELECT * FROM osm_places;
  ';

  -- Create an index on the materialized view for better query performance
  CREATE INDEX idx_detailed_places_view_location ON public.detailed_places_view USING gist (location);
  CREATE INDEX idx_detailed_places_view_osm_id ON public.detailed_places_view (osm_id);
  CREATE INDEX idx_detailed_places_view_category_id ON public.detailed_places_view (category_id);


  -- Grant necessary permissions
  GRANT SELECT ON public.detailed_places_view TO PUBLIC;

END;
$$ LANGUAGE plpgsql;

-- Create a function to refresh the materialized view
CREATE OR REPLACE FUNCTION refresh_detailed_places_view()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.detailed_places_view;
END;
$$ LANGUAGE plpgsql;