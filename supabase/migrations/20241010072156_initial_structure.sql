-- Extensions
CREATE EXTENSION IF NOT EXISTS "hstore" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "moddatetime" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "postgis" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "postgres_fdw" WITH SCHEMA "extensions";
CREATE EXTENSION IF NOT EXISTS "pg_jsonschema" WITH SCHEMA "extensions";

-- Foreign Data Wrapper setup
CREATE SERVER osm_remote_server FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host '135.181.108.171', dbname 'postgres', port '5433');
CREATE USER MAPPING FOR CURRENT_USER SERVER osm_remote_server OPTIONS (user 'postgres', password 'p4ik5IdbSwQBMaUNBUgashGjZUxBhkN9Autx9R9Yj9VeXNgOIMYzhIuapPKn8ti1');
CREATE SCHEMA IF NOT EXISTS osm_import;
IMPORT FOREIGN SCHEMA public FROM SERVER osm_remote_server INTO osm_import;

-- Custom types
CREATE TYPE "public"."contribution_action" AS ENUM ('ADD', 'UPDATE', 'REPORT', 'PHOTO_UPLOAD');
CREATE TYPE "public"."contribution_status" AS ENUM ('PENDING', 'APPROVED', 'REJECTED');

-- Sequences
CREATE SEQUENCE "public"."user_notifications_notification_id_seq";
CREATE SEQUENCE "public"."place_entrances_id_seq";
CREATE SEQUENCE "public"."places_place_id_seq";

-- Tables
CREATE TABLE "public"."users" (
    "id" uuid NOT NULL PRIMARY KEY,
    "email" text,
    "first_name" text,
    "last_name" text
);

CREATE TABLE "public"."user_notifications" (
    "notification_id" integer NOT NULL DEFAULT nextval('user_notifications_notification_id_seq'::regclass) PRIMARY KEY,
    "user_id" uuid,
    "message" text NOT NULL,
    "is_read" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT now()
);

CREATE TABLE "public"."place_categories" (
    "category_id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "name" text NOT NULL,
    "name_sv" text NOT NULL,
    "parent_category_id" bigint,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text)
);

-- After creating the place_categories table, add this:
INSERT INTO "public"."place_categories" ("name", "name_sv", "parent_category_id", "created_at", "updated_at") VALUES
    ('Finance', 'Finans', NULL, NOW(), NOW()),
    ('Food & Drink', 'Mat & Dryck', NULL, NOW(), NOW()),
    ('Leisure', 'Fritid', NULL, NOW(), NOW()),
    ('Culture', 'Kultur', NULL, NOW(), NOW()),
    ('Health', 'Hälsa och Vård', NULL, NOW(), NOW()),
    ('Shopping', 'Affär', NULL, NOW(), NOW()),
    ('Education', 'Utbildning', NULL, NOW(), NOW()),
    ('Sport', 'Sport', NULL, NOW(), NOW()),
    ('Accommodation', 'Boende och Hotell', NULL, NOW(), NOW()),
    ('Transport', 'Transport', NULL, NOW(), NOW()),
    ('Authorities', 'Myndigheter och Service', NULL, NOW(), NOW()),
    ('Tourism', 'Turism', NULL, NOW(), NOW()),
    ('Toilets', 'Toaletter', NULL, NOW(), NOW()),
    ('Other', 'Övrigt', NULL, NOW(), NOW());

-- Then, insert child categories
INSERT INTO "public"."place_categories" ("name", "name_sv", "parent_category_id", "created_at", "updated_at") VALUES
    ('ATM', 'Bankomat', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Finance'), NOW(), NOW()),
    ('Bank', 'Bank', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Finance'), NOW(), NOW()),
    ('Bar/Pub', 'Bar/Pub', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Bakery', 'Bageri', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Restaurant', 'Restaurang', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Burger Restaurant', 'Hamburgerrestaurang', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Pizzeria', 'Pizzeria', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Kebab Shop', 'Kebabrestaurang', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Sushi Bar', 'Sushibar', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Ice Cream Parlor', 'Glasskiosk', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Fast Food', 'Snabbmat', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Coffee Shop', 'Café', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Sandwich Shop', 'Smörgåsbutik', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Food & Drink'), NOW(), NOW()),
    ('Gym', 'Gym', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Leisure'), NOW(), NOW()),
    ('Fitness Station', 'Utegym', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Leisure'), NOW(), NOW()),
    ('Swimming Pool', 'Simhall', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Leisure'), NOW(), NOW()),
    ('Playground', 'Lekplats', (SELECT category_id FROM "public"."place_categories" WHERE name = 'Leisure'), NOW(), NOW());

    
CREATE TABLE "public"."place_osm_tag_to_category" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "tag_key" text NOT NULL,
    "tag_value" text NOT NULL,
    "category_id" bigint,
    "priority" integer NOT NULL DEFAULT 0,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text)
);

CREATE TABLE "public"."entrance_types" (
    "id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    "name" text NOT NULL,
    "name_sv" text NOT NULL,
    "description" text,
    "description_sv" text,
    "is_active" boolean NOT NULL DEFAULT true,
    "max_per_place" integer DEFAULT NULL,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text)
);

CREATE TABLE "public"."places" (
    "place_id" integer NOT NULL DEFAULT nextval('places_place_id_seq'::regclass) PRIMARY KEY,
    "osm_id" bigint,
    "name" character varying(255),
    "location" geometry(Point,4326),
    "category_id" bigint,
    "osm_tags" jsonb,
    "user_id" uuid,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text)
);

CREATE TABLE "public"."place_entrances" (
    "entrance_id" integer NOT NULL DEFAULT nextval('place_entrances_id_seq'::regclass) PRIMARY KEY,
    "place_id" integer NOT NULL,
    "type_id" integer NOT NULL,
    "location" geometry,
    "accessibility_info" jsonb,
    "created_at" timestamp with time zone DEFAULT now(),
    "updated_at" timestamp with time zone DEFAULT now()
);

CREATE TABLE "public"."place_entrance_photos" (
    "photo_id" bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "place_id" integer,
    "user_id" uuid,
    "photo_url" character varying,
    "description" text,
    "entrance_id" integer,
    "created_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone DEFAULT (now() AT TIME ZONE 'utc'::text)
);

CREATE TABLE "public"."entity_changes_staging" (
    "id" serial PRIMARY KEY,
    "user_id" uuid NOT NULL,
    "entity_id" integer NOT NULL,
    "entity_type" text NOT NULL CHECK (entity_type IN ('place', 'entrance', 'photo')),
    "action_type" text NOT NULL CHECK (action_type IN ('add', 'update', 'delete')),
    "change_data" jsonb NOT NULL,
    "status" text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    "submitted_at" timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone
);

CREATE TABLE "public"."entity_changes_audit " (
    "id" serial PRIMARY KEY,
    "staging_change_id" int,
    "user_id" uuid NOT NULL,
    "entity_id" int NOT NULL,
    "entity_type" text NOT NULL CHECK (entity_type IN ('place', 'entrance', 'photo')),
    "action_type" text NOT NULL CHECK (action_type IN ('add', 'update', 'delete')),
    "change_data" jsonb NOT NULL,
    "status" text NOT NULL CHECK (status IN ('approved', 'rejected')),
    "reviewed_by" uuid,
    "reviewed_at" timestamp NOT NULL,
    "audit_timestamp" timestamp DEFAULT now()
);

CREATE TABLE public.entity_json_schemas (
  entity_type text PRIMARY KEY,
  json_schema jsonb NOT NULL
);

-- Insert schemas for each entity type
INSERT INTO public.entity_json_schemas (entity_type, json_schema) VALUES
  ('place', '{
    "type": "object",
    "properties": {
      "name": { "type": "string" },
      "location": { "type": "object", "properties": { "lat": { "type": "number" }, "long": { "type": "number" } }, "required": ["lat", "long"] },
      "category_id": { "type": "integer" }
    },
    "required": ["name", "location", "category_id"]
  }'::jsonb),
  ('entrance', '{
    "type": "object",
    "properties": {
      "type_id": { "type": "integer" },
      "place_id": { "type": "integer" },
      "osm_id": { "type": "integer" },
      "photo_url": { "type": "string" },
      "location": { "type": "object", "properties": { "lat": { "type": "number" }, "long": { "type": "number" } }, "required": ["lat", "long"] }
    },
    "required": ["type_id", "location", "photo_url"]
  }'::jsonb),
  ('photo', '{
    "type": "object",
    "properties": {
      "photo_url": { "type": "string" },
      "description": { "type": "string" },
      "place_id": { "type": "integer" }
    },
    "required": ["photo_url", "place_id"]
  }'::jsonb);


-- Indexes
CREATE INDEX "idx_place_entrance_photos_place_id" ON public.place_entrance_photos USING btree (place_id);
CREATE INDEX "idx_place_entrance_photos_user_id" ON public.place_entrance_photos USING btree (user_id);
CREATE INDEX "idx_places_category_id" ON public.places USING btree (category_id);
CREATE INDEX "idx_places_location" ON public.places USING gist (location);
CREATE INDEX "idx_places_osm_id" ON public.places USING btree (osm_id);
CREATE INDEX "idx_entity_changes_staging_user_id" ON public.entity_changes_staging USING btree (user_id);
CREATE INDEX "idx_entity_changes_staging_entity_id" ON public.entity_changes_staging USING btree (entity_id);
CREATE UNIQUE INDEX "unique_name" ON public.place_categories USING btree (name);

-- Foreign Keys
ALTER TABLE "public"."place_osm_tag_to_category" ADD CONSTRAINT "tag_category_mapping_place_category_id_fkey" FOREIGN KEY (category_id) REFERENCES place_categories(category_id) ON UPDATE CASCADE ON DELETE SET NULL;
ALTER TABLE "public"."place_categories" ADD CONSTRAINT "place_categories_parent_category_fkey" FOREIGN KEY (parent_category_id) REFERENCES place_categories(category_id);
ALTER TABLE "public"."place_entrances" ADD CONSTRAINT "place_entrances_place_id_fkey" FOREIGN KEY (place_id) REFERENCES places(place_id) ON DELETE CASCADE;
ALTER TABLE "public"."place_entrance_photos" ADD CONSTRAINT "place_entrance_photos_entrance_id_fkey" FOREIGN KEY (entrance_id) REFERENCES place_entrances(entrance_id);
ALTER TABLE "public"."place_entrance_photos" ADD CONSTRAINT "place_entrance_photos_place_id_fkey" FOREIGN KEY (place_id) REFERENCES places(place_id) ON DELETE CASCADE;
ALTER TABLE "public"."places" ADD CONSTRAINT "places_category_id_fkey" FOREIGN KEY (category_id) REFERENCES place_categories(category_id);
ALTER TABLE "public"."places" ADD CONSTRAINT "places_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL;
ALTER TABLE "public"."entity_changes_staging" ADD CONSTRAINT "entity_changes_staging_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id);
ALTER TABLE "public"."entity_changes_audit " ADD CONSTRAINT "entity_changes_audit _staging_change_id_fkey" FOREIGN KEY (staging_change_id) REFERENCES entity_changes_staging(id);
ALTER TABLE "public"."entity_changes_audit " ADD CONSTRAINT "entity_changes_audit _user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id);
ALTER TABLE "public"."entity_changes_audit " ADD CONSTRAINT "entity_changes_audit _reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES users(id);

-- Functions
CREATE OR REPLACE FUNCTION public.add_place_from_osm(osm_id bigint)
RETURNS places
LANGUAGE plpgsql
AS $function$
DECLARE
    osm_name TEXT;
    osm_tags HSTORE;
    osm_location GEOMETRY;
    place_category_id INTEGER;
    new_place places%ROWTYPE;
BEGIN
    -- Fetch OSM information from sweden_osm_poi
    SELECT n.tags->'name',
           n.tags,
           n.geom
    INTO osm_name, osm_tags, osm_location
    FROM osm_import.sweden_osm_poi n
    WHERE n.osm_id = $1;

    -- If no OSM record is found, raise an error
    IF osm_name IS NULL THEN
        RAISE EXCEPTION 'OSM ID % does not exist or has no name', $1;
    END IF;

    -- Determine the category using the existing function
    SELECT get_category_id_from_osm_tags(osm_tags)
    INTO place_category_id;

    -- Insert a new place into the places table and get the entire inserted row
    INSERT INTO places (
        osm_id,
        name,
        location,
        osm_tags,
        category_id,
        created_at,
        updated_at
    )
    VALUES (
        $1,
        osm_name,
        osm_location,
        hstore_to_jsonb(osm_tags),
        place_category_id,
        NOW(),
        NOW()
    )
    RETURNING * INTO new_place;

    -- Raise a notice for successful creation
    RAISE NOTICE 'Place created successfully for OSM ID %', $1;

    -- Return the entire inserted row
    RETURN new_place;
END;
$function$;

CREATE OR REPLACE FUNCTION public.check_email_exists(email character varying)
RETURNS boolean
LANGUAGE plpgsql
STABLE SECURITY DEFINER
SET search_path TO 'public'
AS $function$
DECLARE
    val VARCHAR;
BEGIN
    SELECT u.email INTO val FROM users u
    WHERE u.email = LOWER($1);  -- Use function argument explicitly to avoid ambiguity

    IF FOUND THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$function$;

CREATE OR REPLACE FUNCTION public.get_category_id_from_osm_tags(tags hstore)
RETURNS integer
LANGUAGE plpgsql
STABLE
AS $function$
DECLARE
    cat_id INTEGER;
    other_category_id INTEGER;
    current_key TEXT;
    current_value TEXT;
BEGIN
    -- First, try to find an exact match
    SELECT category_id INTO cat_id
    FROM place_osm_tag_to_category
    WHERE (tag_key, tag_value) IN (SELECT key, value FROM each(tags))
    ORDER BY priority DESC
    LIMIT 1;

    -- If no exact match, try wildcard matches
    IF cat_id IS NULL THEN
        FOR current_key, current_value IN SELECT key, value FROM each(tags)
        LOOP
            -- Try to match the specific key with a wildcard value
            SELECT category_id INTO cat_id
            FROM place_osm_tag_to_category
            WHERE tag_key = current_key AND tag_value = '*'
            ORDER BY priority DESC
            LIMIT 1;

            EXIT WHEN cat_id IS NOT NULL;
        END LOOP;
    END IF;

    -- If a category is found, log it and return
    IF cat_id IS NOT NULL THEN
        RAISE NOTICE 'Category found: %', cat_id;
        RETURN cat_id;
    END IF;

    -- If no category found, set it to 'Other'
    SELECT category_id INTO other_category_id 
    FROM place_categories 
    WHERE name = 'Other'
    LIMIT 1;
    
    IF other_category_id IS NULL THEN
        RAISE EXCEPTION 'Other category not found in place_categories';
    END IF;

    RAISE NOTICE 'No specific category found. Using Other category: %', other_category_id;
    RETURN other_category_id;

EXCEPTION
    WHEN too_many_rows THEN
        RAISE EXCEPTION 'Multiple categories found for the given tags. Please refine the mapping.';
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error in get_category_id_from_osm_tags: %', SQLERRM;
END;
$function$;

CREATE OR REPLACE FUNCTION public.get_nearest_places(
    user_lat double precision,
    user_long double precision,
    limit_count integer DEFAULT 10,
    max_distance_meters double precision DEFAULT 10000
)
RETURNS TABLE(
    place_id integer,
    osm_id bigint,
    name text,
    lat double precision,
    long double precision,
    distance_meters double precision,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    osm_tags jsonb,
    user_id uuid,
    category_name text,
    parent_category_name text
)
LANGUAGE plpgsql
AS $function$
DECLARE
    user_location geometry;
BEGIN
    PERFORM set_config('search_path', 'public, extensions', false);

    -- Create a point geometry from the input latitude and longitude
    user_location := ST_SetSRID(ST_MakePoint(user_long, user_lat), 4326);

    RETURN QUERY
    SELECT 
        v.place_id,
        v.osm_id,
        v.name::TEXT,
        ST_Y(v.location::geometry) AS lat,
        ST_X(v.location::geometry) AS long,
        ST_Distance(v.location::geography, user_location::geography) AS distance_meters,
        v.created_at,
        v.updated_at,
        v.osm_tags,
        v.user_id,
        v.category_name::TEXT,
        v.parent_category_name::TEXT
    FROM detailed_places_view v
    WHERE ST_DWithin(
        v.location::geography,
        user_location::geography,
        max_distance_meters
    )
    ORDER BY v.location::geography <-> user_location::geography
    LIMIT limit_count;
END;
$function$;

CREATE OR REPLACE FUNCTION public.process_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.users (id, email)
  VALUES (NEW.id, NEW.email);
  RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.check_valid_osm_id()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only validate if osm_id is NOT NULL
  IF NEW.osm_id IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1 FROM osm_import.sweden_osm_poi
      WHERE osm_id = NEW.osm_id
    ) THEN
      RAISE EXCEPTION 'Invalid osm_id: %', NEW.osm_id;
    END IF;
  END IF;
  RETURN NEW;
END;
$function$;

CREATE OR REPLACE FUNCTION public.refresh_detailed_places_view()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.detailed_places_view;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_entrance_type_counts(p_place_id INTEGER)
RETURNS TABLE (type_id INTEGER, count BIGINT) 
LANGUAGE SQL
AS $$
    SELECT type_id, COUNT(*) as count
    FROM place_entrances
    WHERE place_id = p_place_id
    GROUP BY type_id;
$$;

-- add_entity_change
CREATE OR REPLACE FUNCTION public.add_entity_change(
  p_user_id UUID,
  p_entity_id INTEGER DEFAULT NULL,
  p_entity_type TEXT DEFAULT NULL,
  p_action_type TEXT DEFAULT NULL,
  p_change_data JSONB DEFAULT '{}'::JSONB
)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_entity_change_id INTEGER;
  v_json_schema JSON;
  v_is_valid BOOLEAN;
BEGIN
  -- Check if entity_type and action_type are null
  IF p_entity_type IS NULL THEN
    RAISE EXCEPTION 'entity_type cannot be null';
  END IF;

  IF p_action_type IS NULL THEN
    RAISE EXCEPTION 'action_type cannot be null';
  END IF;

  -- Fetch the schema for the specified entity type
  SELECT json_schema INTO v_json_schema
  FROM public.entity_json_schemas
  WHERE entity_type = p_entity_type;

  -- Validate the change_data against the schema
  SELECT extensions.json_matches_schema(v_json_schema::json, p_change_data::json) INTO v_is_valid;

  -- If validation fails, raise an error
  IF NOT v_is_valid THEN
    RAISE EXCEPTION 'Invalid change_data for entity_type %s, expected %, got %', p_entity_type, v_json_schema, p_change_data;
  END IF;

  -- Start transaction
  BEGIN
    -- Insert into entity_changes_staging
    INSERT INTO entity_changes_staging (
      user_id,
      entity_id,
      entity_type,
      action_type,
      change_data,
      status
    ) VALUES (
      p_user_id,
      p_entity_id,
      p_entity_type,
      p_action_type,
      p_change_data,
      'pending'
    )
    RETURNING id INTO v_entity_change_id;

    -- If we get here, commit the transaction
    RETURN v_entity_change_id;
  EXCEPTION
    WHEN OTHERS THEN
      -- If any error occurs, the transaction will be rolled back automatically
      RAISE;
  END;
END;
$$;
-- end add_entity_change

-- Views
CREATE OR REPLACE VIEW "public"."detailed_entrances_view" AS 
SELECT 
    se.entrance_id,
    se.place_id,
    p.osm_id,
    p.name AS place_name,
    se.type_id AS entrance_type_id,
    et.name AS entrance_type_name,
    et.name_sv AS entrance_type_name_sv,
    et.description AS entrance_type_description,
    et.description_sv AS entrance_type_description_sv,
    p.location,
    st_y(se.location) AS lat,
    st_x(se.location) AS long,
    se.accessibility_info,
    se.created_at AS entrance_created_at,
    se.updated_at AS entrance_updated_at,
    et.created_at AS entrance_type_created_at,
    -- Aggregate multiple photos for each entrance
    json_agg(
        json_build_object(
            'photo_id', pei.photo_id,
            'photo_url', pei.photo_url,
            'description', pei.description,
            'user_id', pei.user_id,
            'created_at', pei.created_at
        )
    ) AS photos  -- Collect all photos for this entrance
FROM place_entrances se
JOIN places p ON p.place_id = se.place_id
JOIN entrance_types et ON et.id = se.type_id
LEFT JOIN place_entrance_photos pei ON pei.entrance_id = se.entrance_id  -- Join photos
GROUP BY se.entrance_id, p.place_id, et.id;



CREATE MATERIALIZED VIEW public.detailed_places_view AS
WITH custom_places AS (
SELECT 
    p.place_id,
    p.osm_id,
    p.name,
    p.osm_tags,
    ST_Y(p.location::geometry) AS lat,
    ST_X(p.location::geometry) AS long,
    p.location,
    p.created_at,
    p.updated_at,
    p.user_id,
    c.category_id,
    c.name AS category_name,
    c.name_sv AS category_name_sv,
    pc.category_id AS parent_category_id,
    pc.name AS parent_category_name,
    pc.name_sv AS parent_category_name_sv,
    NULL AS source,
    CASE WHEN pe.place_id IS NOT NULL THEN true ELSE false END AS has_entrances
FROM public.places p
LEFT JOIN place_categories c ON p.category_id = c.category_id
LEFT JOIN place_categories pc ON c.parent_category_id = pc.category_id
LEFT JOIN (
    SELECT DISTINCT place_id
    FROM public.place_entrances
) pe ON p.place_id = pe.place_id
),
osm_places AS (
SELECT 
    NULL::integer AS id,
    osm.osm_id,
    osm.name,
    osm.tags::jsonb AS osm_tags,
    ST_Y(osm.geom::geometry) AS lat,
    ST_X(osm.geom::geometry) AS long,
    osm.geom AS location,
    NULL::timestamp with time zone AS created_at,
    NULL::timestamp with time zone AS updated_at,
    NULL::uuid AS user_id,
    osm_c.category_id AS category_id,
    osm_c.name AS category_name,
    osm_c.name_sv AS category_name_sv,
    osm_pc.category_id AS parent_category_id,
    osm_pc.name AS parent_category_name,
    osm_pc.name_sv AS parent_category_name_sv,
    'osm' AS source,
    false AS has_entrances
FROM osm_import.sweden_osm_poi osm
LEFT JOIN LATERAL (
    SELECT public.get_category_id_from_osm_tags(osm.tags::hstore) AS category_id
) AS osm_category ON true
LEFT JOIN place_categories osm_c ON osm_category.category_id = osm_c.category_id
LEFT JOIN place_categories osm_pc ON osm_c.parent_category_id = osm_pc.category_id
WHERE osm.name IS NOT NULL
    AND osm.osm_id NOT IN (SELECT p2.osm_id FROM public.places p2 WHERE p2.osm_id IS NOT NULL)
LIMIT 100
)
SELECT * FROM custom_places
UNION ALL
SELECT * FROM osm_places;



CREATE OR REPLACE FUNCTION public.get_place_entrances_with_pending(
  p_place_id INTEGER, 
  p_user_id UUID DEFAULT NULL
)
RETURNS TABLE (
  entrance_id INTEGER,
  entrance_type_id INTEGER,
  location geometry,
  photos jsonb,
  status TEXT
)
LANGUAGE SQL
AS $$
WITH verified_entrances AS (
  SELECT 
    de.entrance_id,
    de.entrance_type_id,
    de.location,
    json_agg(json_build_object(
        'photo_id', img->>'photo_id',
        'photo_url', img->>'photo_url',
        'description', img->>'description'
    )) AS photos,
    'approved' AS status  -- Mark as approved since it's from verified data
  FROM detailed_entrances_view de
  LEFT JOIN LATERAL jsonb_array_elements(de.photos::jsonb) AS img ON true  -- Cast to jsonb
  WHERE de.place_id = p_place_id
  GROUP BY de.entrance_id, de.entrance_type_id, de.location
),
pending_entrances AS (
  SELECT 
    ecs.entity_id AS entrance_id,
    (ecs.change_data->>'type_id')::integer AS entrance_type_id,  -- Cast to integer
    ST_GeomFromGeoJSON(ecs.change_data->>'location') AS location,
    json_agg(json_build_object(
        'photo_url', img->>'photo_url', 
        'description', img->>'description'
    )) AS photos,
    ecs.status
  FROM entity_changes_staging ecs
  LEFT JOIN LATERAL jsonb_array_elements(ecs.change_data->'photos') AS img ON true
  WHERE ecs.entity_id = p_place_id
    AND ecs.entity_type = 'entrance'
    AND ecs.action_type = 'add'
    AND ecs.status = 'pending'
    AND (p_user_id IS NULL OR ecs.user_id = p_user_id)
  GROUP BY ecs.entity_id, ecs.status, ecs.change_data->>'location', ecs.change_data->>'type_id'
)
-- Combine verified and pending entrances
SELECT * FROM verified_entrances
UNION ALL
SELECT * FROM pending_entrances
ORDER BY entrance_type_id;
$$;



-- Grant necessary permissions
GRANT SELECT ON public.detailed_places_view TO PUBLIC;
CREATE INDEX idx_detailed_places_view_location ON public.detailed_places_view USING gist (location);
CREATE INDEX idx_detailed_places_view_osm_id ON public.detailed_places_view (osm_id);
CREATE INDEX idx_detailed_places_view_category_id ON public.detailed_places_view (category_id);



-- Triggers
CREATE TRIGGER check_osm_id BEFORE INSERT OR UPDATE ON public.places FOR EACH ROW EXECUTE FUNCTION check_valid_osm_id();

-- Permissions
-- Grant statements for tables and functions remain unchanged

-- Policies
CREATE POLICY "Enable read access for all users" ON "public"."places" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."place_categories" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."place_entrances" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."place_entrance_photos" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable read access for all users" ON "public"."entrance_types" AS PERMISSIVE FOR SELECT TO public USING (true);

--CREATE POLICY "Enable insert for authenticated users only" ON "public"."entity_changes_staging" AS PERMISSIVE FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable insert for public users" ON "public"."entity_changes_staging" AS PERMISSIVE FOR INSERT TO public WITH CHECK (true);
CREATE POLICY "Enable read access for public users" ON "public"."entity_changes_staging" AS PERMISSIVE FOR SELECT TO public USING (true);
CREATE POLICY "Enable update for public users" ON "public"."entity_changes_staging" AS PERMISSIVE FOR UPDATE TO public USING (true) WITH CHECK (true);
CREATE POLICY "Enable delete for public users" ON "public"."entity_changes_staging" AS PERMISSIVE FOR DELETE TO public USING (true);

-- Enable Row Level Security
ALTER TABLE "public"."place_osm_tag_to_category" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."place_categories" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."place_entrances" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."place_entrance_photos" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entity_changes_staging" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."entity_changes_audit " ENABLE ROW LEVEL SECURITY;

-- Storage
ALTER TABLE "storage"."buckets" ENABLE ROW LEVEL SECURITY;

-- Policy for SELECT operations: Allow all users to read objects
CREATE POLICY "Enable read access for all users" ON storage.objects
FOR SELECT USING (true);

-- Policy for INSERT operations: Allow authenticated users to upload objects
CREATE POLICY "Enable upload for authenticated users only" ON storage.objects
FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Policy for UPDATE operations: Allow authenticated users to update their own objects
CREATE POLICY "Enable update for users based on user_id" ON storage.objects
FOR UPDATE USING (auth.uid() = owner);

-- Policy for DELETE operations: Allow authenticated users to delete their own objects
CREATE POLICY "Enable delete for users based on user_id" ON storage.objects
FOR DELETE USING (auth.uid() = owner);

-- End of Storage

set check_function_bodies = off;

grant delete on table "public"."user_notifications" to "anon";

grant insert on table "public"."user_notifications" to "anon";

grant references on table "public"."user_notifications" to "anon";

grant select on table "public"."user_notifications" to "anon";

grant trigger on table "public"."user_notifications" to "anon";

grant truncate on table "public"."user_notifications" to "anon";

grant update on table "public"."user_notifications" to "anon";

grant delete on table "public"."user_notifications" to "authenticated";

grant insert on table "public"."user_notifications" to "authenticated";

grant references on table "public"."user_notifications" to "authenticated";

grant select on table "public"."user_notifications" to "authenticated";

grant trigger on table "public"."user_notifications" to "authenticated";

grant truncate on table "public"."user_notifications" to "authenticated";

grant update on table "public"."user_notifications" to "authenticated";

grant delete on table "public"."user_notifications" to "postgres";

grant insert on table "public"."user_notifications" to "postgres";

grant references on table "public"."user_notifications" to "postgres";

grant select on table "public"."user_notifications" to "postgres";

grant trigger on table "public"."user_notifications" to "postgres";

grant truncate on table "public"."user_notifications" to "postgres";

grant update on table "public"."user_notifications" to "postgres";

grant delete on table "public"."user_notifications" to "service_role";

grant insert on table "public"."user_notifications" to "service_role";

grant references on table "public"."user_notifications" to "service_role";

grant select on table "public"."user_notifications" to "service_role";

grant trigger on table "public"."user_notifications" to "service_role";

grant truncate on table "public"."user_notifications" to "service_role";

grant update on table "public"."user_notifications" to "service_role";

grant delete on table "public"."place_osm_tag_to_category" to "anon";

grant insert on table "public"."place_osm_tag_to_category" to "anon";

grant references on table "public"."place_osm_tag_to_category" to "anon";

grant select on table "public"."place_osm_tag_to_category" to "anon";

grant trigger on table "public"."place_osm_tag_to_category" to "anon";

grant truncate on table "public"."place_osm_tag_to_category" to "anon";

grant update on table "public"."place_osm_tag_to_category" to "anon";

grant delete on table "public"."place_osm_tag_to_category" to "authenticated";

grant insert on table "public"."place_osm_tag_to_category" to "authenticated";

grant references on table "public"."place_osm_tag_to_category" to "authenticated";

grant select on table "public"."place_osm_tag_to_category" to "authenticated";

grant trigger on table "public"."place_osm_tag_to_category" to "authenticated";

grant truncate on table "public"."place_osm_tag_to_category" to "authenticated";

grant update on table "public"."place_osm_tag_to_category" to "authenticated";

grant delete on table "public"."place_osm_tag_to_category" to "postgres";

grant insert on table "public"."place_osm_tag_to_category" to "postgres";

grant references on table "public"."place_osm_tag_to_category" to "postgres";

grant select on table "public"."place_osm_tag_to_category" to "postgres";

grant trigger on table "public"."place_osm_tag_to_category" to "postgres";

grant truncate on table "public"."place_osm_tag_to_category" to "postgres";

grant update on table "public"."place_osm_tag_to_category" to "postgres";

grant delete on table "public"."place_osm_tag_to_category" to "service_role";

grant insert on table "public"."place_osm_tag_to_category" to "service_role";

grant references on table "public"."place_osm_tag_to_category" to "service_role";

grant select on table "public"."place_osm_tag_to_category" to "service_role";

grant trigger on table "public"."place_osm_tag_to_category" to "service_role";

grant truncate on table "public"."place_osm_tag_to_category" to "service_role";

grant update on table "public"."place_osm_tag_to_category" to "service_role";

grant delete on table "public"."place_categories" to "anon";

grant insert on table "public"."place_categories" to "anon";

grant references on table "public"."place_categories" to "anon";

grant select on table "public"."place_categories" to "anon";

grant trigger on table "public"."place_categories" to "anon";

grant truncate on table "public"."place_categories" to "anon";

grant update on table "public"."place_categories" to "anon";

grant delete on table "public"."place_categories" to "authenticated";

grant insert on table "public"."place_categories" to "authenticated";

grant references on table "public"."place_categories" to "authenticated";

grant select on table "public"."place_categories" to "authenticated";

grant trigger on table "public"."place_categories" to "authenticated";

grant truncate on table "public"."place_categories" to "authenticated";

grant update on table "public"."place_categories" to "authenticated";

grant delete on table "public"."place_categories" to "postgres";

grant insert on table "public"."place_categories" to "postgres";

grant references on table "public"."place_categories" to "postgres";

grant select on table "public"."place_categories" to "postgres";

grant trigger on table "public"."place_categories" to "postgres";

grant truncate on table "public"."place_categories" to "postgres";

grant update on table "public"."place_categories" to "postgres";

grant delete on table "public"."place_categories" to "service_role";

grant insert on table "public"."place_categories" to "service_role";

grant references on table "public"."place_categories" to "service_role";

grant select on table "public"."place_categories" to "service_role";

grant trigger on table "public"."place_categories" to "service_role";

grant truncate on table "public"."place_categories" to "service_role";

grant update on table "public"."place_categories" to "service_role";

grant delete on table "public"."place_entrances" to "anon";

grant insert on table "public"."place_entrances" to "anon";

grant references on table "public"."place_entrances" to "anon";

grant select on table "public"."place_entrances" to "anon";

grant trigger on table "public"."place_entrances" to "anon";

grant truncate on table "public"."place_entrances" to "anon";

grant update on table "public"."place_entrances" to "anon";

grant delete on table "public"."place_entrances" to "authenticated";

grant insert on table "public"."place_entrances" to "authenticated";

grant references on table "public"."place_entrances" to "authenticated";

grant select on table "public"."place_entrances" to "authenticated";

grant trigger on table "public"."place_entrances" to "authenticated";

grant truncate on table "public"."place_entrances" to "authenticated";

grant update on table "public"."place_entrances" to "authenticated";

grant delete on table "public"."place_entrances" to "postgres";

grant insert on table "public"."place_entrances" to "postgres";

grant references on table "public"."place_entrances" to "postgres";

grant select on table "public"."place_entrances" to "postgres";

grant trigger on table "public"."place_entrances" to "postgres";

grant truncate on table "public"."place_entrances" to "postgres";

grant update on table "public"."place_entrances" to "postgres";

grant delete on table "public"."place_entrances" to "service_role";

grant insert on table "public"."place_entrances" to "service_role";

grant references on table "public"."place_entrances" to "service_role";

grant select on table "public"."place_entrances" to "service_role";

grant trigger on table "public"."place_entrances" to "service_role";

grant truncate on table "public"."place_entrances" to "service_role";

grant update on table "public"."place_entrances" to "service_role";

grant delete on table "public"."place_entrance_photos" to "anon";

grant insert on table "public"."place_entrance_photos" to "anon";

grant references on table "public"."place_entrance_photos" to "anon";

grant select on table "public"."place_entrance_photos" to "anon";

grant trigger on table "public"."place_entrance_photos" to "anon";

grant truncate on table "public"."place_entrance_photos" to "anon";

grant update on table "public"."place_entrance_photos" to "anon";

grant delete on table "public"."place_entrance_photos" to "authenticated";

grant insert on table "public"."place_entrance_photos" to "authenticated";

grant references on table "public"."place_entrance_photos" to "authenticated";

grant select on table "public"."place_entrance_photos" to "authenticated";

grant trigger on table "public"."place_entrance_photos" to "authenticated";

grant truncate on table "public"."place_entrance_photos" to "authenticated";

grant update on table "public"."place_entrance_photos" to "authenticated";

grant delete on table "public"."place_entrance_photos" to "postgres";

grant insert on table "public"."place_entrance_photos" to "postgres";

grant references on table "public"."place_entrance_photos" to "postgres";

grant select on table "public"."place_entrance_photos" to "postgres";

grant trigger on table "public"."place_entrance_photos" to "postgres";

grant truncate on table "public"."place_entrance_photos" to "postgres";

grant update on table "public"."place_entrance_photos" to "postgres";

grant delete on table "public"."place_entrance_photos" to "service_role";

grant insert on table "public"."place_entrance_photos" to "service_role";

grant references on table "public"."place_entrance_photos" to "service_role";

grant select on table "public"."place_entrance_photos" to "service_role";

grant trigger on table "public"."place_entrance_photos" to "service_role";

grant truncate on table "public"."place_entrance_photos" to "service_role";

grant update on table "public"."place_entrance_photos" to "service_role";

grant delete on table "public"."places" to "anon";

grant insert on table "public"."places" to "anon";

grant references on table "public"."places" to "anon";

grant select on table "public"."places" to "anon";

grant trigger on table "public"."places" to "anon";

grant truncate on table "public"."places" to "anon";

grant update on table "public"."places" to "anon";

grant delete on table "public"."places" to "authenticated";

grant insert on table "public"."places" to "authenticated";

grant references on table "public"."places" to "authenticated";

grant select on table "public"."places" to "authenticated";

grant trigger on table "public"."places" to "authenticated";

grant truncate on table "public"."places" to "authenticated";

grant update on table "public"."places" to "authenticated";

grant delete on table "public"."places" to "postgres";

grant insert on table "public"."places" to "postgres";

grant references on table "public"."places" to "postgres";

grant select on table "public"."places" to "postgres";

grant trigger on table "public"."places" to "postgres";

grant truncate on table "public"."places" to "postgres";

grant update on table "public"."places" to "postgres";

grant delete on table "public"."places" to "service_role";

grant insert on table "public"."places" to "service_role";

grant references on table "public"."places" to "service_role";

grant select on table "public"."places" to "service_role";

grant trigger on table "public"."places" to "service_role";

grant truncate on table "public"."places" to "service_role";

grant update on table "public"."places" to "service_role";

grant delete on table "public"."users" to "anon";

grant insert on table "public"."users" to "anon";

grant references on table "public"."users" to "anon";

grant select on table "public"."users" to "anon";

grant trigger on table "public"."users" to "anon";

grant truncate on table "public"."users" to "anon";

grant update on table "public"."users" to "anon";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "postgres";

grant insert on table "public"."users" to "postgres";

grant references on table "public"."users" to "postgres";

grant select on table "public"."users" to "postgres";

grant trigger on table "public"."users" to "postgres";

grant truncate on table "public"."users" to "postgres";

grant update on table "public"."users" to "postgres";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";